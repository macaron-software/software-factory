RLM Light Agent - Task: Tu es un agent TDD autonome pour Veligo (v√©los en libre-service).

## T√ÇCHE
Task T018: Corriger 34 TODO/FIXME dans le backend

## D√âTAILS
# Task T018: Corriger 34 TODO/FIXME dans le backend

**Priority**: P2
**Time Estimate**: 1.5h
**WSJF Score**: 5.0
**Complexity**: medium
**Queue**: TDD

## Description
34 TODO/FIXME/XXX identifi√©s. Prioriser et r√©soudre les plus critiques.

## Success Criteria
- [ ] TODOs r√©duits √† < 10
- [ ] TODOs restants document√©s avec issue tracker
- [ ] Pas de unimplemented!() en production

## Actions
1. grep -r 'TODO|FIXME|XXX|unimplemented!' backend/src/
2. Trier par criticit√© (unimplemented! = P0)
3. R√©soudre les plus critiques
4. Cr√©er tickets pour les autres

## Files to Create/Modify
- [ ] veligo-platform/backend/src/**/*.rs (MODIFY)

## Ralph Status Block
---RALPH_STATUS---
STATUS: IN_PROGRESS
COMPLEXITY: medium
MODEL_TIER: TIER3
WSJF: 5.0
---END_RALPH_STATUS---

## Adversarial Feedback
üö® MENSONGE: Pr√©tend 'tests pass' sans ex√©cuter de commande de test
üö® HALLUCINATION: Fichier mentionn√© n'existe pas: /Users/sylvain/_LAPOSTE/_VELIGO2/veligo-cli/src/main.rs

## Adversarial Feedback
üö® HALLUCINATION: Fichier mentionn√© n'existe pas: /Users/sylvain/_LAPOSTE/_VELIGO2/veligo-platform/backend/src/api/admin_api.rs

## üî¥ R√àGLE ABSOLUE: V√âRIFIER AVANT MODIFIER

AVANT de modifier ou cr√©er un fichier, tu DOIS:
1. Utiliser `Read` pour V√âRIFIER que le fichier existe
2. Utiliser `veligo_grep` pour trouver les patterns existants
3. NE JAMAIS inventer un fichier qui n'existe pas

Si un fichier n'existe pas:
- Cherche un fichier similaire avec `Glob` ou `veligo_rag_query`
- Adapte ton approche au code R√âEL

## INSTRUCTIONS TDD (Red ‚Üí Green)

1. **PHASE EXPLORATION**: Comprendre le contexte
   - `veligo_rag_query("test skip failing")` pour trouver tests probl√©matiques
   - `veligo_grep("TODO|FIXME", "*.rs")` pour trouver points d'attention
   - `Read` sur les fichiers mentionn√©s pour V√âRIFIER qu'ils existent

2. **PHASE RED**: Lis le test qui √©choue
   - Utilise `Read` pour voir le fichier test (V√âRIFIE qu'il existe!)
   - Comprends ce que le test attend

3. **PHASE CODE**: Impl√©mente la solution
   - Utilise `Read` AVANT d'utiliser `Edit`
   - Modifie max 3 fichiers
   - Fais des changements minimaux

4. **PHASE GREEN**: V√©rifie
   - Rust: `cargo test --lib`
   - Frontend: `npm run test`
   - E2E: `npx playwright test <file>`

## R√àGLES ANTI-HALLUCINATION
- ‚ùå JAMAIS modifier un fichier sans l'avoir lu d'abord
- ‚ùå JAMAIS inventer un chemin de fichier
- ‚ùå JAMAIS pr√©tendre "tests pass" sans ex√©cuter la commande
- ‚úÖ Utilise veligo_grep pour trouver le bon fichier
- ‚úÖ Utilise Read pour v√©rifier l'existence

## OUTILS MCP DISPONIBLES
- veligo_rag_query: Recherche s√©mantique dans le code
- veligo_ao_search: Recherche dans les specs AO
- veligo_grep: Grep pattern dans fichiers

Commence maintenant. R√©ponds avec: SUCCESS ou NEEDS_MORE_WORK
Backend: auto
Local: http://127.0.0.1:8002/v1/chat/completions (qwen3)
Cloud: https://api.minimax.io/v1/chat/completions (MiniMax-M2.1)

--- Iteration 1/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
L'utilisateur me demande de corriger des TODO/FIXME dans le backend Veligo. Commen√ßons par explorer le code pour trouver les fichiers et les TODOs.

D'abord, je vais utiliser grep pour trouver les TODO/FIXME dans le backend.
</think>


{"tool": "grep", "pattern": "TODO|FIXME|XXX|unimplemented!", "path": "backend/src/**/*.rs"}...
TOOL [grep]: No matches found...

--- Iteration 2/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Interesting - no TODO/FIXME/XXX/unimplemented! patterns found in backend/src/**/*.rs. Let me verify this by checking the actual path structure. The user mentioned the path might be different. Let me first check what exists in the backend directory.
</think>

{"tool": "bash", "command": "find backend -name \"*.rs\" 2>/dev/null | head -20 || echo \"No backend dir or no .rs files found\""}...
TOOL [bash]: exit_code=0
...

--- Iteration 3/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Le r√©pertoire backend n'existe pas. Je dois explorer la structure du projet pour trouver o√π se trouve le code backend.
</think>

{"tool": "bash", "command": "ls -la && find . -type d -name \"*backend*\" -o -type d -name \"*platform*\" 2>/dev/null | head -20"}...
TOOL [bash]: exit_code=0
total 9168
drwxr-xr-x  235 sylvain  staff    7520 Jan 13 16:05 .
drwxr-xr-x   50 sylvain  staff    1600 Dec 16 20:12 ..
-rw-r--r--    1 sylvain  staff   14340 Jan 13 11:32 .DS_Store
drwxr-...

--- Iteration 4/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Il semble que le projet est √† la racine. Je vois un Cargo.toml, donc c'est un projet Rust. Laissez-moi chercher les fichiers Rust et les TODO/FIXME dans le projet.
</think>


{"tool": "bash", "command": "find . -name \"*.rs\" -type f 2>/dev/null | xargs grep -l \"TODO\\|FIXME\\|XXX\\|unimplemented!\" 2>/dev/null | head -30"}...
TOOL [bash]: exit_code=0
./veligo-platform/tenant/backend-api/tests/e2e/test_helpers_fixed.rs
./veligo-platform/tenant/backend-api/tests/e2e/mod.rs
./veligo-platform/tenant/backend-api/tests/e2e/test_helpers.rs
./...

--- Iteration 5/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
J'ai trouv√© les fichiers avec des TODOs/FIXMEs. Je dois maintenant compter le nombre total et les lister pour voir leur criticit√©. Je vais d'abord compter le nombre total de TODOs/FIXMEs et voir les unimplemented!() en priorit√©.
</think>

{"tool": "bash", "command": "grep -r \"TODO\\|FIXME\\|XXX\\|unimplemented!\" --include=\"*.rs\" veligo-platform/tenant/backend-api/src/ 2>/dev/null | wc -l"}...
TOOL [bash]: exit_code=0
      72
...

--- Iteration 6/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
72 occurrences de TODO/FIXME/XXX/unimplemented! dans le code source (pas les tests). La t√¢che dit 34 TODO/FIXME, donc je dois tous les lister et les cat√©goriser par criticit√©.

Commen√ßons par lister tous les TODO/FIXME avec leur contexte pour prioriser.
</think>

{"tool": "bash", "command": "grep -rn \"TODO\\|FIXME\\|XXX\\|unimplemented!\" --include=\"*.rs\" veligo-platform/tenant/backend-api/src/ 2>/dev/null"}...
TOOL [bash]: exit_code=0
veligo-platform/tenant/backend-api/src/bin/tonic-server.rs:68:        // TODO: Save to database
veligo-platform/tenant/backend-api/src/bin/tonic-server.rs:108:        // TODO: Query from d...

--- Iteration 7/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Il y a 72 TODO/FIXME/XXX dans le backend. La t√¢che mentionne 34, donc peut-√™tre qu'il y a eu des ajouts ou des suppressions depuis. Je dois maintenant :

1. Identifier les P0 (unimplemented!) - aucun trouv√©
2. Prioriser les plus critiques
3. R√©soudre les plus importants

Les TODO les plus critiques sont ceux dans :
- src/application/commands/ (logique m√©tier)
- src/infrastructure/http/ (endpoints API)
- src/infrastructure/adapters/payment/ (paiements)

Je vais commencer par lire les fich...
TOOL [bash]: exit_code=0
      72
...

--- Iteration 8/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
72 TODOs/FIXMEs dans le backend (pas 34 comme mentionn√© dans la task, mais je vais commencer √† les traiter).

La task demande de:
1. R√©duire √† < 10 TODOs
2. Documenter les restants avec issue tracker
3. Pas de unimplemented!() en production

D'apr√®s la liste, il y a 72 TODOs. Je vais commencer par les plus critiques (unimplemented! en P0, puis les TODOs dans le code de production).

Regardons s'il y a des `unimplemented!()` dans le code de production (pas les tests):
</think>

{"tool": "...
TOOL [bash]: exit_code=1
...

--- Iteration 9/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Pas de `unimplemented!()` trouv√© dans le code source. C'est une bonne nouvelle - pas de P0 critical.

Maintenant je dois prioriser les 72 TODO/FIXME. Les plus critiques sont ceux qui bloquent des fonctionnalit√©s ou repr√©sentent des risques de s√©curit√©.

Regardons plus en d√©tail:
1. Les TODOs dans le code de production (src/) - surtout ceux li√©s √† la s√©curit√©, persistence, et fonctionnalit√©s critiques
2. Les TODOs dans les tests (tests/) - moins prioritaires

Commen√ßons par analyser les f...
TOOL [bash]: exit_code=0
    Checking nu-ansi-term v0.50.3
    Checking bitflags v1.3.2
    Checking system-configuration v0.5.1
    Checking thrift v0.17.0
    Checking simple_asn1 v0.6.3
    Checking yaml-rust2 ...

--- Iteration 10/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Il y a un probl√®me de build avec les fichiers proto. Mais ce n'est pas directement li√© aux TODOs. Laissez-moi me concentrer sur la t√¢che principale: identifier et prioriser les TODOs/FIXME.

Le task dit qu'il y a 34 TODO/FIXME, mais j'en ai trouv√© 72. Je vais maintenant analyser et prioriser les plus critiques.

Commen√ßons par les P0: unimplemented!() - il n'y en a pas.

Les P1 devraient √™tre les fonctionnalit√©s critiques qui bloquent ou qui ont un impact majeur.

Regardons les fichiers ...
TOOL [read]: // Trace: Sprint 004 - 2025-12-11T12:46:10Z - Payment Adapter Factory

use super::mock_adapter::MockPaymentAdapter;
use crate::domain::payment::{PaymentError, PaymentPort, PaymentProvider};
use std::s...

--- Iteration 11/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Ce fichier contient 3 TODOs qui sont document√©s et ont des alternatives (erreurs explicites). C'est acceptable pour MVP. Je vais continuer √† analyser les autres fichiers pour trouver les plus critiques.

Voyons les fichiers HTTP routes qui ont beaucoup de TODOs non impl√©ment√©s.
</think>


{"tool": "read", "path": "veligo-platform/tenant/backend-api/src/infrastructure/http/admin_owner_routes.rs"}...
TOOL [read]: use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::IntoResponse,
    routing::{delete, get, patch, post, put},
    Json, Router,
};
use serde::{Deserialize, Serialize};...

--- Iteration 12/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Let me continue reading this file to see the rest of the TODOs, and then analyze the overall situation.

I see that the task mentions 34 TODOs, but when I grepped, I found 72. Let me categorize them by priority:

1. **P0 (Critical)**: `unimplemented!()` - none found ‚úì
2. **P1 (High)**: TODOs in production code that blocks features
3. **P2 (Medium)**: TODOs in non-blocking areas, mock implementations
4. **P3 (Low)**: Documentation, cleanup, test-related

Let me analyze the files and prior...
TOOL [bash]: exit_code=0
warning: /Users/sylvain/_LAPOSTE/_VELIGO2/veligo-platform/tenant/backend-api/Cargo.toml: unused manifest key: profile.test.rand
   Compiling redis v0.24.0
   Compiling veligo-api v0.1.0 (/...

--- Iteration 13/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
The build is failing because of missing proto files. Let me check where the proto files are located and fix this issue first.
</think>

Le build √©choue √† cause de fichiers proto manquants. R√©glons cela en premier.
{"tool": "bash", "command": "find . -name \"*.proto\" -type f 2>/dev/null | head -20"}...
TOOL [bash]: exit_code=0
./veligo-platform/frontend/node_modules/@protobuf-ts/plugin/protobuf-ts.proto
./veligo-platform/proto/tenant/v1/tenant.proto
./veligo-platform/proto/auth/v1/auth.proto
./veligo-platform/pr...

--- Iteration 14/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Les fichiers proto existent. Le probl√®me est que le script de build cherche `../proto/subscription/v1/subscription.proto` depuis le r√©pertoire `backend-api`, mais le chemin correct est `../proto/subscription/v1/subscription.proto` depuis le r√©pertoire `backend-api` qui est dans `veligo-platform/tenant/backend-api`.

Regardons le script de build et la structure des r√©pertoires.
</think>


{"tool": "bash", "command": "ls -la veligo-platform/tenant/backend-api/" && ls -la veligo-platform/pr...
WARNING: No tool call found, asking for completion

--- Iteration 15/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Je vois que les fichiers proto existent √† ./veligo-platform/proto/subscription/v1/subscription.proto mais le build √©choue. Le probl√®me est que le Cargo.toml du backend-api r√©f√©rence ../proto/subscription/v1/subscription.proto de mani√®re relative depuis le r√©pertoire backend-api. Voyons le Cargo.toml.
</think>


{"tool": "read", "path": "veligo-platform/tenant/backend-api/Cargo.toml"}...
TOOL [read]: # Trace: 2025-12-10T13:46:55 - Veligo Backend Cargo Workspace
# Reference: BACKBONE-ARCHITECTURE-RUST.md - Performance: 220K req/s, 15MB RAM

[workspace]

[package]
name = "veligo-api"
version = "0.1....

--- Iteration 16/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Je vois le probl√®me. Le build.rs reference ../proto/subscription/v1/subscription.proto mais il y a un build.rs qui pointe vers le mauvais chemin. Regardons le build.rs.
</think>


{"tool": "bash", "command": "cat veligo-platform/tenant/backend-api/build.rs 2>/dev/null || echo \"build.rs not found\""}...
TOOL [bash]: exit_code=0
fn main() -> Result<(), Box<dyn std::error::Error>> {
    tonic_build::configure()
        .build_server(true)
        .build_client(false)
        .protoc_arg("--experimental_allow_proto3...

--- Iteration 17/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Le probl√®me est que le build.rs tente de compiler des proto qui n'existent pas au chemin sp√©cifi√©. V√©rifions si les fichiers existent:
</think>

{"tool": "bash", "command": "ls -la veligo-platform/proto/subscription/v1/subscription.proto && ls -la veligo-platform/proto/module/v1/module.proto"}...
TOOL [bash]: exit_code=0
-rw-r--r--  1 sylvain  staff  2368 Dec 10 14:51 veligo-platform/proto/subscription/v1/subscription.proto
-rw-r--r--  1 sylvain  staff  2248 Dec 14 15:54 veligo-platform/proto/module/v1/mod...

--- Iteration 18/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Les fichiers proto existent. Le probl√®me est que le build.rs utilise un chemin relatif "../proto" qui ne fonctionne pas depuis le r√©pertoire de travail. Le chemin est correct mais le build √©choue.

Laissez-moi v√©rifier si protoc est install√© et voir l'erreur exacte.
</think>

Les fichiers existent. V√©rifions si protoc est install√©.
{"tool": "bash", "command": "which protoc && protoc --version || echo \"protoc not installed\""}...
TOOL [bash]: exit_code=0
/opt/homebrew/bin/protoc
libprotoc 33.2
...

--- Iteration 19/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Protoc est install√© et les fichiers proto existent. Le probl√®me pourrait √™tre un probl√®me de chemin. Le build.rs utilise `../proto` mais le Cargo.toml est dans `veligo-platform/tenant/backend-api/`. Donc `../proto` pointe vers `veligo-platform/proto/` ce qui semble correct.

V√©rifions si le working directory pose probl√®me.
</think>


{"tool": "bash", "command": "cd veligo-platform/tenant/backend-api && protoc --experimental_allow_proto3_optional -I=../proto ../proto/subscription/v1/subsc...
TOOL [bash]: exit_code=1
../proto: warning: directory does not exist.
Missing output directives.
...

--- Iteration 20/20 ---
CLOUD: Calling https://api.minimax.io/v1/chat/completions with model MiniMax-M2.1
LLM: <think>
Ah, le probl√®me est que le chemin relatif est diff√©rent quand on lance depuis le r√©pertoire backend-api. Le build.rs utilise "../proto" mais depuis backend-api, "../proto" pointe vers le bon endroit. Mais le probl√®me semble √™tre que protoc ne peut pas r√©soudre le chemin relatif dans les messages d'erreur.

Laissez-moi v√©rifier si cargo build fonctionne avec les bonnes variables d'environnement ou si le probl√®me est ailleurs.
</think>


{"tool": "bash", "command": "cd veligo-platform/tena...
TOOL [bash]: exit_code=0
   Compiling nu-ansi-term v0.50.3
   Compiling bitflags v1.3.2
   Compiling base64ct v1.8.1
   Compiling yaml-rust2 v0.8.1
   Compiling password-hash v0.5.0
   Compiling tracing-subscriber...

=== RESULT ===
ERROR: Max iterations reached without completion
