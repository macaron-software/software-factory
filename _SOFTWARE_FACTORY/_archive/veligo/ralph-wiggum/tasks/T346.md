# Task T346: Implémenter BikeService.UpdateBike gRPC

**Priority**: P0
**WSJF Score**: 9.0
**Queue**: TDD
**Type**: backend
**Generated by**: LRM Brain (RLM)

## Description
Implémenter UpdateBike pour modifications partielles bike.

## Success Criteria
- [ ] Tests pass
- [ ] gRPC service functional (if backend)
- [ ] UI matches design (if frontend)
- [ ] No regressions

## Ralph Status Block
---RALPH_STATUS---
STATUS: FAILED
COMPLEXITY: medium
MODEL_TIER: TIER2
WSJF: 9.0
---END_RALPH_STATUS---

## Last Failure (Wed Jan 14 10:15:33 CET 2026)
```
I can see there's an `update_bike` function at line 1119 in bike.rs. Let me look at that function and understand the structure. I need to:

1. Look at the existing update_bike function
2. Look at the proto definition for UpdateBikeRequest to understand the fields
3. Create an UpdateBike command if needed
4. Implement the update_bike method

Let me see the current implementation and the proto definition.
</think>

<read file="veligo-platform/backend/src/grpc/services/bike.rs" start="1115" end="1200"/>
<read file="veligo-platform/proto/bike/v1/bike.proto"/>
<bash>
grep -rn "update_bike" veligo-platform/backend/src/application/commands/</bash>

=== Action Results ===
bash: OK
veligo-platform/backend/src/application/commands/mod.rs:12:pub mod update_bike_status;
veligo-platform/backend/src/application/commands/mod.rs:34:pub use update_bike_status::{
veligo-platform/backend/src/application/commands/mod.rs:35:    execute as update_bike_status, BikeStatusEvent, TargetStatus, UpdateBikeStatusCommand,
```

## Last Failure (Wed Jan 14 10:16:01 CET 2026)
```
```

=== Action Results ===
bash: OK
                });

                Ok(Response::new(GetBikeStatusResponse {
                    status: status_enum,
                    last_seen,
                }))
            }
            None => Err(Status::not_found(format!("Bike {} not found", req.bike_id))),
        }
    }

    // Unimplemented methods (stubs for proto compliance)
    async fn create_bike(
        &self,
        _request: Request<crate::proto::bike::v1::CreateBikeRequest>,
    ) -> Result<Response<ProtoBike>, Status
```

## Last Failure (Wed Jan 14 10:16:38 CET 2026)
```
  BIKE_STATUS_IN_USE = 3;
  BIKE_STATUS_MAINTENANCE = 4;
  BIKE_STATUS_OUT_OF_SERVICE = 5;
  BIKE_STATUS_STOLEN = 6;
}

// Maintenance type
enum MaintenanceType {
  MAINTENANCE_TYPE_UNSPECIFIED = 0;
  MAINTENANCE_TYPE_ROUTINE = 1;
  MAINTENANCE_TYPE_REPAIR = 2;
  MAINTENANCE_TYPE_EMERGENCY = 3;
  MAINTENANCE_TYPE_INSPECTION = 4;
}

// Bike entity
message Bike {
  string id = 1;
  string tenant_id = 2;
  strin
```

## Last Failure (Wed Jan 14 10:17:24 CET 2026)
```
grep -rn "pub struct.*Bike\|impl.*Bike\|bikes\." veligo-platform/backend/src/infrastructure/database/repositories/*.rs | head -30</bash>

=== Action Results ===
bash: OK
veligo-platform/backend/src/infrastructure/database/repositories/subscription_query_service.rs:82:pub struct BikeInfo {


=== LLM Response ===
<think>
Let me search for the actual bike repository. It might be in a different location or structured differently.
</think>

<bash>
grep -rn "update\|UPDATE\|UPDATE_BIKE" veligo-platform/backend/src/infrastructure/database/repositories/*.rs | head -30</bash>

=== Action Results ===
bash: OK
veligo-platform/backend/src/infrastructure/database/repositories/admin.rs:108:            r#"UPDATE tenant_modules SET enabled = true WHERE id = $1 AND tenant_id = $2"#,
veligo-platform/backend/src/infrastructure/database/repositories/admin.rs:125:            r#"UPDATE tenant_modules SET enabled = false WHERE id = $1 AND tenant_id = $2"#,
veligo-platform/backend/src/infrastructure/database/repositories/subscription_query_service.rs:385:                starts_at, ends_at, is_test, data, metadata,
```

## Last Failure (Wed Jan 14 10:17:57 CET 2026)
```

=== Action Results ===
bash: FAIL


=== LLM Response ===
<think>
Let me look at the subscription_query_service.rs file more thoroughly to understand the structure and see how update_bike is implemented. Then I need to understand what needs to be added to the BikeRepository trait and how the gRPC service should call it.
</think>

<read file="veligo-platform/backend/src/infrastructure/database/repositories/subscription_query_service.rs" start="1" end="120"/>
<read file="veligo-platform/backend/src/domain/fleet/repository.rs"/></bash>

=== LLM Response ===
<think>
I need to continue analyzing the task. Let me read the repository file and the subscription_query_service to understand the structure.
</think>

<read file="veligo-platform/backend/src/domain/fleet/repository.rs"/>
<read file="veligo-platform/backend/src/infrastructure/database/repositories/subscription_query_service.rs" start="1" end="150"/></read>
```

## Last Failure (Wed Jan 14 10:18:39 CET 2026)
```
=== Action Results ===
bash: OK
syntax = "proto3";

package veligo.bike.v1;

import "common/v1/common.proto";
import "google/protobuf/timestamp.proto";

// Bike/Fleet Service
service BikeService {
  // CRUD Operations
  rpc GetBike(GetBikeRequest) returns (Bike);
  rpc ListBikes(ListBikesRequest) returns (ListBikesResponse);
  rpc CreateBike(CreateBikeRequest) returns (Bike);
  rpc UpdateBike(UpdateBikeRequest) returns (Bike);
  rpc DeleteBike(DeleteBikeRequest) returns (DeleteBikeResponse);

  // Status Management
  rpc Updat
```
