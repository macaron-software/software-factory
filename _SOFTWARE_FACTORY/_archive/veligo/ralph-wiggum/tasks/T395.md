# Task T395: Module auth-idnum

**Priority**: P1
**WSJF Score**: 8.8
**Queue**: TDD
**Category**: MODULE
**Original ID**: MOD-AUTH-003
**Phase**: üì¶ PHASE 4: MODULES BACKEND (Priority P2)
**Section**: 4.1 Auth Modules

## Description
Module auth-idnum

## Test File
`modules/auth-idnum.spec.ts`

## Estimated Files
4 fichier(s) √† modifier

## Success Criteria
- [ ] Test E2E cr√©√©/modifi√©: `modules/auth-idnum.spec.ts`
- [ ] Test passe en local
- [ ] Pas de test.skip() sans condition
- [ ] Code review adversarial pass√©
- [ ] Pas de stubs ou TODOs

## Definition of Done (DoD)
- [ ] Feature compl√®tement impl√©ment√©e
- [ ] Tests E2E verts
- [ ] Conformit√© AO v√©rifi√©e (si applicable)
- [ ] Documentation mise √† jour

## Ralph Status Block
---RALPH_STATUS---
STATUS: FAILED
COMPLEXITY: medium
WSJF: 8.8
CATEGORY: MODULE
ORIGINAL_ID: MOD-AUTH-003
---END_RALPH_STATUS---

## Last Failure (Wed Jan 14 13:24:36 CET 2026)
```
    InitiateOAuthRequest, InitiateOAuthResponse,
    HandleOAuthCallbackRequest,
    LoginRespo

=== LLM Response ===
<think>
Now I understand the context better. The `auth-idnum` module is a dynamic plugin that needs to be implemented. Let me explore more to understand:
1. What the existing auth plugins look like
2. What the expected interface is for auth-idnum
3. What tests need to be created

Let me check the loader and grpc services more to understand the expected interface.
</think>

```bash
cat veligo-platform/backend/src/grpc/services/auth.rs | grep -A50 "auth-idnum"
```

=== Action Results ===
bash: FAIL
```

## Last Failure (Wed Jan 14 13:25:10 CET 2026)
```
    response::Json as AxumJson,
};
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::error::Error;
use uuid::Uuid;
use chrono::Utc;

// Error types
#[derive(Debug)]
pub enum AuthError {
    Database(sqlx::Error),
    Validation(String),
    Authentication(String),
    RateLimit(String),
}

impl std::fmt::Display for AuthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
```

## Last Failure (Wed Jan 14 13:25:36 CET 2026)
```
    response::Json as AxumJson,
};
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::error::Error;
use uuid::Uuid;
use chrono::Utc;

// Error types
#[derive(Debug)]
pub enum AuthError {
    Database(sqlx::Error),
    Validation(String),
    Authentication(String),
    RateLimit(String),
}

impl std::fmt::Display for AuthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
```

## Last Failure (Wed Jan 14 13:25:54 CET 2026)
```
</bash>

=== Action Results ===
bash: OK
syntax = "proto3";

package veligo.auth.v1;

import "google/protobuf/timestamp.proto";

// Authentication Service
service AuthService {
  // Email + Password
  rpc LoginEmailPassword(LoginEmailPasswordRequest) returns (LoginResponse);
  rpc RegisterEmailPassword(RegisterEmailPasswordRequest) returns (RegisterResponse);
  rpc Verify2FA(Verify2FARequest) returns (VerifyResponse);
  
  // Phone + SMS
  rpc SendSmsCode(SendSmsCodeRequest) returns (SendSmsCodeResponse);
  rpc VerifySmsCode(VerifySmsC
```

## Last Failure (Wed Jan 14 13:26:46 CET 2026)
```
 * - Session management
 * - Protected routes
 * - Token refresh
 *
 * Run with: npx playwright test tests/e2e/auth.spec.ts
 */

import { test, expect, type Page } from '@playwright/test';

const BASE_URL = process.env.BASE_URL || 'http://localhost:5173';

// Test credentials
const validCredentials = {
  email: 'user@example.com',
  password: 'SecurePassword123!',
};

const adminCredentials = {
  email: 'admin@veligo.fr',
  password: 'AdminSecu
```

## Last Failure (Wed Jan 14 13:27:18 CET 2026)
```
    response::Json as AxumJson,
};
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::error::Error;
use uuid::Uuid;
use chrono::Utc;

// Error types
#[derive(Debug)]
pub enum AuthError {
    Database(sqlx::Error),
    Validation(String),
    Authentication(String),
    RateLimit(String),
}

impl std::fmt::Display for AuthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
```

## Last Failure (Wed Jan 14 13:27:29 CET 2026)
```
  2:     extract::{Json, State},
  3:     http::StatusCode,
  4:     response::Json as AxumJson,
  5: };
  6: use serde::{Deserialize, Serialize};
  7: use sqlx::PgPool;
  8: use std::error::Error;
  9: use uuid::Uuid;
 10: use chrono::Utc;
 11: 
 12: // Error types
 13: #[derive(Debug)]
 14: pub enum AuthError {
 15:     Database(sqlx::Error),
 16:     Validation(String),
 17:     Authentication(String),
 18:     RateLimit(String),
 19: }
 20: 
 21: impl std::f
```

## Last Failure (Wed Jan 14 13:27:48 CET 2026)
```
    response::Json as AxumJson,
};
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::error::Error;
use uuid::Uuid;
use chrono::Utc;

// Error types
#[derive(Debug)]
pub enum AuthError {
    Database(sqlx::Error),
    Validation(String),
    Authentication(String),
    RateLimit(String),
}

impl std::fmt::Display for AuthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
```

## Last Failure (Wed Jan 14 13:29:19 CET 2026)
```
# Reference: BACKBONE-ARCHITECTURE-RUST.md - Performance: 220K req/s, 15MB RAM

[package]
name = "veligo-api"
version.workspace = true
edition.workspace = true
authors.workspace = true

[features]
default = []
test-utils = []

[dependencies]
# Workspace crates
veligo-shared = { workspace = true }

# Web framework
axum = { workspace = true }
axum-extra = { version = "0.9", features = ["cookie-private", "typed-header"] }
tower = { workspace =
```
