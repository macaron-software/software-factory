# Task T205: Implement CancelReservation gRPC method

**Priority**: P1
**Queue**: TDD
**Type**: implementation

## File
veligo-platform/backend/src/grpc/services/bike.rs

## Description
Implement CancelReservation to cancel an existing reservation

## Success Criteria
- [ ] Implementation complete
- [ ] cargo check passes
- [ ] Unit tests added
- [ ] No new warnings

## Ralph Status Block
---RALPH_STATUS---
STATUS: COMPLETED
COMPLEXITY: medium
WSJF: 8
---END_RALPH_STATUS---

## Last Failure (Tue Jan 13 23:53:54 CET 2026)
```
```bash
sed -n '1,150p' veligo-platform/backend/src/grpc/services/bike.rs
```

=== Action Results ===
bash: OK
// Bike gRPC Service Implementation
// PR-003: Bike gRPC Service
// Date: 2026-01-03

use sqlx::{PgPool, Row};
use std::sync::Arc;
use tonic::{Request, Response, Status};
use uuid::Uuid;

// Import generated proto types from parent module (tonic-server.rs)
// Since this file is included via #[path], we use the parent's proto module
use crate::proto::bike::v1::bike_service_server::BikeService;
use crate::proto::bike::v1::{
    Bike as ProtoBike, BikeStatus as ProtoBikeStatus, BikeType as ProtoBik
```

## Last Failure (Tue Jan 13 23:54:45 CET 2026)
```
sed -n '1115,1189p' veligo-platform/backend/src/grpc/services/bike.rs
```

=== Action Results ===
bash: OK
    async fn create_bike(
        &self,
        _request: Request<crate::proto::bike::v1::CreateBikeRequest>,
    ) -> Result<Response<ProtoBike>, Status> {
        Err(Status::unimplemented("CreateBike is not yet implemented"))
    }

    async fn update_bike(
        &self,
        _request: Request<crate::proto::bike::v1::UpdateBikeRequest>,
    ) -> Result<Response<ProtoBike>, Status> {
        Err(Status::unimplemented("UpdateBike is not yet implemented"))
    }

    async fn delete_bike(
```

## Last Failure (Tue Jan 13 23:55:52 CET 2026)
```
```

=== Action Results ===
bash: OK
        let mut bikes = Vec::new();
        for row in rows {
            bikes.push(self.db_row_to_proto_bike(&row).await?);
        }

        Ok(Response::new(ListBikesResponse {
            bikes,
            meta: None,
            total_count,
        }))
    }

    async fn get(&self, request: Request<GetRequest>) -> Result<Response<ProtoBike>, Status> {
        // Get metadata before consuming request
        let metadata = request.metadata().clone();
        let req = request.into_inner
```
