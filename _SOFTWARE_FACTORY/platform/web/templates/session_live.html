{% extends "base.html" %}

{% block topbar_actions %}
<div style="display:flex;align-items:center;gap:12px;">
    <span class="badge {% if session.status == 'active' %}badge-green{% elif session.status == 'completed' %}badge-blue{% elif session.status == 'failed' %}badge-red{% else %}badge-yellow{% endif %}">
        {{ session.status }}
    </span>
    {% if session.status == 'active' %}
    <button class="btn btn-sm btn-danger"
            hx-post="/api/sessions/{{ session.id }}/stop"
            hx-swap="none"
            hx-on::after-request="location.reload()">
        <svg class="icon icon-sm"><use href="#icon-stop"/></svg> Stop
    </button>
    {% elif session.status in ('completed', 'failed', 'interrupted') %}
    <button class="btn btn-sm" style="background:var(--purple);color:#fff;"
            hx-post="/api/sessions/{{ session.id }}/resume"
            hx-swap="none"
            hx-on::after-request="location.reload()">
        <svg class="icon icon-sm"><use href="#icon-play"/></svg> Reprendre
    </button>
    {% endif %}
</div>
{% endblock %}

{% block content %}
<link rel="stylesheet" href="/static/css/live.css?v=20260221">

<div class="session-wrap">
  <!-- Header -->
  <div class="session-header">
    <div class="session-title">
      Session: "{{ session.name }}"
      <span class="session-status">
        <span class="dot {% if session.status == 'active' %}dot--active{% elif session.status == 'thinking' %}dot--thinking{% elif session.status == 'failed' %}dot--error{% endif %}"></span>
        {{ session.status }}
      </span>
    </div>
    <div class="session-tabs">
      <button class="session-tab active" data-tab="thread"><svg class="icon icon-xs"><use href="#icon-clipboard"/></svg> Thread</button>
      <button class="session-tab" data-tab="chat"><svg class="icon icon-xs"><use href="#icon-send"/></svg> Chat</button>
      <button class="session-tab" data-tab="graph"><svg class="icon icon-xs"><use href="#icon-share"/></svg> Graph</button>
    </div>
  </div>

  <!-- Content area -->
  <div class="session-content">
    <!-- MODE 1: Thread -->
    <div class="session-pane active" id="pane-thread">
      <div class="thread-feed" id="threadFeed">
        {% set has_agent_msgs = messages | selectattr('from_agent', 'ne', 'user') | selectattr('from_agent', 'ne', 'system') | selectattr('type', 'ne', 'system') | list | length > 0 %}
        {% if (not has_agent_msgs) or session.status in ('completed', 'failed', 'interrupted') %}
        <div class="session-suggestions" id="suggestionsPanel">
          {% if session.goal %}
          <div class="suggestions-goal">
            <svg class="icon icon-sm" style="color:var(--purple)"><use href="#icon-target"/></svg>
            {{ session.goal }}
          </div>
          {% endif %}
          {% if suggestions %}
          <div class="suggestions-label">Démarrez la conversation :</div>
          <div class="suggestions-grid">
            {% for icon, label, prompt in suggestions %}
            <button class="suggestion-badge" data-prompt="{{ prompt }}" onclick="useSuggestion(this)">
              <svg class="icon icon-sm suggestion-icon"><use href="#icon-{{ icon }}"/></svg>
              <span class="suggestion-label">{{ label }}</span>
            </button>
            {% endfor %}
          </div>
          {% endif %}
        </div>
        {% endif %}
        {% set msg_mode = 'thread' %}
        {% for msg in messages %}
        {% include "partials/msg_unified.html" %}
        {% endfor %}
      </div>
    </div>

    <!-- MODE 2: Chat + Panel -->
    <div class="session-pane" id="pane-chat">
      <div class="chat-split">
        <div class="chat-main">
          <div class="chat-selector">
            <label style="font-size:0.78rem;color:var(--text-secondary);margin-right:0.4rem">Chat with:</label>
            <div class="agent-dropdown" id="chatAgentDropdown">
              <button type="button" class="agent-dropdown__trigger" id="chatAgentTrigger">
                {% if agents %}
                {% set first = agents[0] %}
                {% if first.avatar_url %}<img src="{{ first.avatar_url }}" alt="" class="agent-dropdown__photo">{% endif %}
                <span class="agent-dropdown__name">{{ first.name }}</span>
                <span class="agent-dropdown__role">{{ first.role }}</span>
                {% endif %}
                <svg class="icon icon-xs agent-dropdown__chevron"><use href="#icon-chevron-down"/></svg>
              </button>
              <input type="hidden" id="chatAgentSelect" value="{{ agents[0].id if agents else '' }}">
              <div class="agent-dropdown__menu" id="chatAgentMenu">
                {% for a in agents %}
                <div class="agent-dropdown__item{% if loop.first %} active{% endif %}" data-value="{{ a.id }}">
                  {% if a.avatar_url %}<img src="{{ a.avatar_url }}" alt="" class="agent-dropdown__photo">
                  {% else %}<span class="agent-dropdown__initials" style="background:{{ a.color }}20;color:{{ a.color }}">{{ a.avatar[:2] }}</span>{% endif %}
                  <span class="agent-dropdown__name">{{ a.name }}</span>
                  <span class="agent-dropdown__role">{{ a.role }}</span>
                </div>
                {% endfor %}
              </div>
            </div>
          </div>
          <div class="chat-messages" id="chatMessages"></div>
        </div>
        <div class="chat-panel">
          <div class="chat-panel-header">
            <span>Inter-Agent Feed</span>
            <div class="chat-panel-filters">
              <button class="panel-filter active" data-filter="all">All</button>
              <button class="panel-filter" data-filter="decisions">Decisions</button>
              <button class="panel-filter" data-filter="errors">Errors</button>
            </div>
          </div>
          <div class="chat-panel-feed" id="panelFeed"></div>
        </div>
      </div>
    </div>

    <!-- MODE 3: Graph Live -->
    <div class="session-pane" id="pane-graph">
      <div class="graph-split">
        <div class="graph-canvas" id="graphCanvas">
          <svg id="liveSvg" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <marker id="arrow-sequential" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M0,0 L10,5 L0,10 z" fill="#3b82f6" opacity="0.8"/>
              </marker>
              <marker id="arrow-hierarchical" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M0,0 L10,5 L0,10 z" fill="#f59e0b" opacity="0.8"/>
              </marker>
              <marker id="arrow-parallel" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M0,0 L10,5 L0,10 z" fill="#10b981" opacity="0.8"/>
              </marker>
              <marker id="arrow-loop" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M0,0 L10,5 L0,10 z" fill="#ec4899" opacity="0.8"/>
              </marker>
              <marker id="arrow-network" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M0,0 L10,5 L0,10 z" fill="#8b5cf6" opacity="0.8"/>
              </marker>
              <marker id="arrow-report" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M0,0 L10,5 L0,10 z" fill="#ef4444" opacity="0.8"/>
              </marker>
              <marker id="arrow-default" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M0,0 L10,5 L0,10 z" fill="#6b7280" opacity="0.6"/>
              </marker>
            </defs>
            <g id="livePhases"></g>
            <g id="liveEdges"></g>
            <g id="liveNodes"></g>
          </svg>
          <!-- Pattern Legend -->
          <div class="graph-legend" id="graphLegend">
            <div class="graph-legend-title">Patterns</div>
            <div class="graph-legend-items"></div>
          </div>
          <!-- Zoom controls -->
          <div class="graph-zoom-controls">
            <button class="graph-zoom-btn" id="zoomIn" title="Zoom in">+</button>
            <div class="graph-zoom-level" id="zoomLevel">100%</div>
            <button class="graph-zoom-btn" id="zoomOut" title="Zoom out">−</button>
            <button class="graph-zoom-btn" id="zoomFit" title="Fit all" style="font-size:0.72rem;margin-top:2px">⊞</button>
          </div>
          <!-- Minimap -->
          <div class="graph-minimap" id="graphMinimap"><svg id="minimapSvg" xmlns="http://www.w3.org/2000/svg"></svg></div>
          <div class="node-tooltip" id="nodeTooltip"></div>
          <!-- Agent Chat 1:1 panel -->
          <div class="agent-chat-panel" id="agentChatPanel">
            <div class="agent-chat-header">
              <div class="agent-chat-avatar" id="acAvatar"></div>
              <div class="agent-chat-info">
                <div class="agent-chat-name" id="acName"></div>
                <div class="agent-chat-role" id="acRole"></div>
                <div class="agent-chat-status-bar">
                  <span class="agent-chat-status-dot" id="acStatusDot"></span>
                  <span class="agent-chat-status-text" id="acStatusText">idle</span>
                </div>
              </div>
              <button class="agent-chat-close" id="acClose"><svg class="icon"><use href="#icon-x"/></svg></button>
            </div>
            <div class="agent-chat-skills" id="acSkills"></div>
            <div class="agent-chat-actions" id="acActions">
              <button class="agent-chat-action" data-action="status"><svg class="icon icon-xs"><use href="#icon-activity"/></svg> Status</button>
              <button class="agent-chat-action" data-action="review"><svg class="icon icon-xs"><use href="#icon-eye"/></svg> Review</button>
              <button class="agent-chat-action" data-action="delegate"><svg class="icon icon-xs"><use href="#icon-send"/></svg> Delegate</button>
            </div>
            <div class="agent-chat-messages" id="acMessages"></div>
            <div class="agent-chat-typing" id="acTyping">
              Thinking<span class="dots"><span>.</span><span>.</span><span>.</span></span>
            </div>
            <div class="agent-chat-input-bar">
              <input type="text" class="agent-chat-input" id="acInput" placeholder="Message this agent..." autocomplete="off">
              <button class="agent-chat-send" id="acSend"><svg class="icon icon-xs"><use href="#icon-send"/></svg></button>
            </div>
          </div>
        </div>
        <!-- Memory sidebar -->
        <div class="graph-memory" id="memoryPanel">
          <!-- PR List -->
          <div class="graph-memory-title">
            <svg class="icon icon-xs"><use href="#icon-git-pull-request"/></svg> PRs & Deliverables
            {% if memory.prs %}<span class="pr-counter">{{ memory.prs|selectattr('done')|list|length }}/{{ memory.prs|length }}</span>{% endif %}
          </div>
          {% if memory.prs %}
            {% for pr in memory.prs %}
            <div class="pr-item {% if pr.done %}pr-done{% endif %}">
              <span class="pr-check">{% if pr.done %}<svg class="icon icon-xs" style="color:var(--green)"><use href="#icon-check"/></svg>{% else %}<svg class="icon icon-xs" style="opacity:.3"><use href="#icon-circle"/></svg>{% endif %}</span>
              <div>
                <div class="pr-title">{{ pr.title[:70] }}{% if pr.title|length > 70 %}…{% endif %}</div>
                <div class="pr-agent">{{ pr.agent }}</div>
              </div>
            </div>
            {% endfor %}
          {% else %}
            <div class="graph-memory-empty">No PRs yet — agents will produce [PR] items</div>
          {% endif %}

          <!-- Artifacts: decisions, reports -->
          <div class="graph-memory-title" style="margin-top:10px"><svg class="icon icon-xs"><use href="#icon-file-text"/></svg> Artifacts & Decisions</div>
          {% if memory.artifacts %}
            {% for a in memory.artifacts %}
            <div class="graph-memory-entry" style="border-left:3px solid {% if a.type == 'veto' %}var(--red){% elif a.type == 'approve' %}var(--green){% else %}var(--purple){% endif %};padding-left:8px">
              <div class="graph-memory-key">{{ a.icon }} {{ a.title[:50] }}{% if a.title|length > 50 %}…{% endif %}</div>
              <div class="graph-memory-meta">{{ a.agent }} · {{ a.type }}</div>
            </div>
            {% endfor %}
          {% else %}
            <div class="graph-memory-empty">No artifacts yet</div>
          {% endif %}

          <div class="graph-memory-title" style="margin-top:12px"><svg class="icon icon-xs"><use href="#icon-database"/></svg> Session Memory</div>
          {% if memory.session %}
            {% for m in memory.session %}
            <div class="graph-memory-entry">
              <div class="graph-memory-key">{{ m.key }}</div>
              <div class="graph-memory-val">{{ m.value[:200] }}</div>
              <div class="graph-memory-meta">{{ m.author_agent or 'system' }} · {{ m.type or 'context' }}</div>
            </div>
            {% endfor %}
          {% else %}
            <div class="graph-memory-empty">No session memory yet</div>
          {% endif %}

          <div class="graph-memory-title"><svg class="icon icon-xs"><use href="#icon-folder"/></svg> Project Memory</div>
          {% if memory.project %}
            {% for m in memory.project %}
            <div class="graph-memory-entry">
              <div class="graph-memory-key">{{ m.key }}</div>
              <div class="graph-memory-val">{{ m.value[:200] }}</div>
              <div class="graph-memory-meta">{{ m.source or 'system' }} · {{ m.category or 'context' }}</div>
            </div>
            {% endfor %}
          {% else %}
            <div class="graph-memory-empty">No project memory yet</div>
          {% endif %}

          <div class="graph-memory-title"><svg class="icon icon-xs"><use href="#icon-share"/></svg> Shared Memory</div>
          {% if memory.shared %}
            {% for m in memory.shared %}
            <div class="graph-memory-entry">
              <div class="graph-memory-key">{{ m.key }}</div>
              <div class="graph-memory-val">{{ m.value[:200] }}</div>
              <div class="graph-memory-meta">{{ m.category or 'global' }}</div>
            </div>
            {% endfor %}
          {% else %}
            <div class="graph-memory-empty">No shared memory yet</div>
          {% endif %}
        </div>
        <div class="graph-log" id="graphLog">
          {% for msg in messages %}
          {% set fa = agents | selectattr('id', 'equalto', msg.from_agent) | first %}
          {% set ta = agents | selectattr('id', 'equalto', msg.to_agent) | first %}
          <div class="graph-log-line">
            <span class="graph-log-time">{{ msg.timestamp }}</span>
            <span class="graph-log-from">{{ fa.avatar if fa else '?' }} {{ fa.name if fa else msg.from_agent }}</span>
            <span class="graph-log-arrow">→</span>
            <span class="graph-log-to">{{ ta.name if ta else (msg.to_agent or 'all') }}</span>
            <span class="graph-log-content" data-type="{{ msg.type }}">{% if msg.type == 'veto' %}[VETO] {% elif msg.type == 'approve' %}[OK] {% endif %}{{ msg.content[:100] }}</span>
          </div>
          {% endfor %}
          <button class="graph-new-btn" id="graphNewBtn" onclick="scrollGraphLog()"><svg class="icon icon-xs"><use href="#icon-arrow-right"/></svg> New messages</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bottom input bar -->
  <div class="session-input">
    <div class="agent-dropdown agent-dropdown--compact" id="targetAgentDropdown">
      <button type="button" class="agent-dropdown__trigger agent-dropdown__trigger--compact" id="targetAgentTrigger">
        <svg class="icon icon-xs" style="color:var(--text-secondary)"><use href="#icon-users"/></svg>
        <span class="agent-dropdown__name">All agents</span>
        <svg class="icon icon-xs agent-dropdown__chevron"><use href="#icon-chevron-down"/></svg>
      </button>
      <input type="hidden" id="targetAgent" value="">
      <div class="agent-dropdown__menu agent-dropdown__menu--up" id="targetAgentMenu">
        <div class="agent-dropdown__item active" data-value="">
          <svg class="icon icon-xs" style="color:var(--text-secondary)"><use href="#icon-users"/></svg>
          <span class="agent-dropdown__name">All agents</span>
          <span class="agent-dropdown__role"></span>
        </div>
        {% for n in graph.nodes %}
        {% set a = agents | selectattr('id', 'equalto', n.agent_id) | first %}
        <div class="agent-dropdown__item" data-value="{{ n.agent_id }}">
          {% if a and a.avatar_url %}<img src="{{ a.avatar_url }}" alt="" class="agent-dropdown__photo">
          {% else %}<span class="agent-dropdown__initials" style="background:{{ a.color if a else '#6b7280' }}20;color:{{ a.color if a else '#6b7280' }}">{{ a.avatar[:2] if a else '??' }}</span>{% endif %}
          <span class="agent-dropdown__name">{{ a.name if a else n.label }}</span>
          <span class="agent-dropdown__role">{{ a.role if a else '' }}</span>
        </div>
        {% endfor %}
      </div>
    </div>
    <input type="text" id="msgInput" class="input-text" placeholder="{% if session.status == 'completed' %}Session terminée — écris un message pour reprendre...{% else %}Send a message...{% endif %}" autocomplete="off">
    <button id="btnConversation" class="input-conv" title="Lancer une conversation multi-agents (les agents discutent entre eux)"><svg class="icon icon-sm"><use href="#icon-message-circle"/></svg></button>
    <button id="btnSend" class="input-send"><svg class="icon icon-xs"><use href="#icon-send"/></svg></button>
  </div>
</div>

<script>
/* ── Suggestion badge click → fill input + send ── */
function useSuggestion(btn) {
  const prompt = btn.dataset.prompt;
  const input = document.getElementById('msgInput');
  const sendBtn = document.getElementById('btnSend');
  if (input && prompt) {
    input.value = prompt;
    input.focus();
    // Auto-send after a short delay so user sees what's being sent
    setTimeout(() => { if (sendBtn) sendBtn.click(); }, 150);
    // Hide suggestions panel
    const panel = document.getElementById('suggestionsPanel');
    if (panel) panel.style.display = 'none';
  }
}

(function(){
"use strict";

/* ── Bootstrap data ── */
const SESSION_ID = {{ session.id | tojson }};
const AGENTS = {{ agents | tojson }};
const GRAPH  = {{ graph | tojson if graph else '{"nodes":[],"edges":[]}' }};
const NODE_W = 230, NODE_H = 110;

function agentById(id){ return AGENTS.find(a=>a.id===id) || null; }
function esc(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/"/g,'&quot;'); }
function cleanLLM(s){
  // Strip <think>...</think> blocks (MiniMax reasoning)
  s = s.replace(/<think>[\s\S]*?<\/think>/g, '');
  // Strip incomplete <think> at end (still streaming)
  s = s.replace(/<think>[\s\S]*$/, '');
  // Strip [TOOL_CALL]...[/TOOL_CALL] blocks
  s = s.replace(/\[TOOL_CALL\][\s\S]*?\[\/TOOL_CALL\]/g, '');
  // Strip incomplete [TOOL_CALL] at end
  s = s.replace(/\[TOOL_CALL\][\s\S]*$/, '');
  // Strip [DELEGATE:...] [VETO:...] [APPROVE] action tags
  s = s.replace(/\[(DELEGATE|VETO|APPROVE|ASK|ESCALATE)[^\]]*\]/g, '');
  return s.trim();
}

function md(s){
  s = cleanLLM(s);
  if (!s) return '';
  // Lightweight markdown: bold, italic, code, headers, lists, links, tables
  let h = esc(s);
  h = h.replace(/^### (.+)$/gm, '<h4>$1</h4>');
  h = h.replace(/^## (.+)$/gm, '<h3>$1</h3>');
  h = h.replace(/^# (.+)$/gm, '<h2>$1</h2>');
  h = h.replace(/`([^`]+)`/g, '<code>$1</code>');
  h = h.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  h = h.replace(/\*([^*]+)\*/g, '<em>$1</em>');
  h = h.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
  // Tables: detect | header | ... | lines
  h = h.replace(/^(\|.+\|)\n(\|[-| :]+\|)\n((?:\|.+\|\n?)*)/gm, (m, hdr, sep, body)=>{
    const th = hdr.split('|').filter(c=>c.trim()).map(c=>`<th>${c.trim()}</th>`).join('');
    const rows = body.trim().split('\n').map(r=>{
      const cells = r.split('|').filter(c=>c.trim()).map(c=>`<td>${c.trim()}</td>`).join('');
      return `<tr>${cells}</tr>`;
    }).join('');
    return `<table><thead><tr>${th}</tr></thead><tbody>${rows}</tbody></table>`;
  });
  h = h.replace(/^- (.+)$/gm, '<li>$1</li>');
  h = h.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
  h = h.replace(/\n/g, '<br>');
  return h;
}

/* ── Tab switching ── */
const tabs = document.querySelectorAll('.session-tab');
const panes = document.querySelectorAll('.session-pane');
let activeTab = localStorage.getItem('session_tab') || 'thread';

function switchTab(tab){
  activeTab = tab;
  localStorage.setItem('session_tab', tab);
  tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  panes.forEach(p => p.classList.toggle('active', p.id === 'pane-'+tab));
  if(tab === 'graph') setTimeout(()=>renderGraph(), 50);
}

tabs.forEach(t => t.addEventListener('click', ()=> switchTab(t.dataset.tab)));
switchTab(activeTab);

/* ── Send message ── */
const msgInput = document.getElementById('msgInput');
const targetAgent = document.getElementById('targetAgent');
const btnSend = document.getElementById('btnSend');

async function sendMessage(){
  const content = msgInput.value.trim();
  if(!content) return;
  const target = targetAgent.value;
  btnSend.disabled = true;
  try{
    await fetch(`/api/sessions/${SESSION_ID}/messages`, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body:`content=${encodeURIComponent(content)}&to_agent=${target}`
    });
    msgInput.value = '';
  } finally { btnSend.disabled = false; }
}

btnSend.addEventListener('click', sendMessage);
msgInput.addEventListener('keydown', e=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendMessage(); }});

/* ── Multi-agent conversation ── */
const btnConv = document.getElementById('btnConversation');
btnConv.addEventListener('click', async ()=>{
  const content = msgInput.value.trim();
  if(!content){ msgInput.placeholder = 'Écris un sujet de discussion pour les agents...'; return; }
  // Gather all agent IDs from the graph
  const agentIds = GRAPH.nodes.map(n => n.agent_id).filter(Boolean);
  if(agentIds.length < 2){
    alert('Il faut au moins 2 agents dans le workflow pour une conversation.');
    return;
  }
  btnConv.disabled = true;
  btnConv.classList.add('active');
  msgInput.value = '';
  try{
    await fetch(`/api/sessions/${SESSION_ID}/conversation`, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body:`message=${encodeURIComponent(content)}&agent_ids=${agentIds.join(',')}&max_rounds=6`
    });
  } finally { btnConv.disabled = false; btnConv.classList.remove('active'); }
});

/* ── SSE Connection ── */
const es = new EventSource(`/api/sessions/${SESSION_ID}/sse`);
const _streamBuffers = {}; // agent_id → {div, content}
es.addEventListener('message', e=>{
  try{
    const data = JSON.parse(e.data);
    if(data.type === 'stream_start') { handleStreamStart(data); return; }
    if(data.type === 'stream_delta') { handleStreamDelta(data); return; }
    if(data.type === 'stream_end')   { handleStreamEnd(data); return; }
    if(data.type === 'conversation_end') { return; }
    appendMessage(data);
    updateNodeStatus(data);
    routeToAgentChat(data);
  }catch(err){ console.error('SSE parse error', err); }
});
es.addEventListener('error', ()=>{ console.warn('SSE connection lost, will retry...'); });

/* ── Streaming handlers ── */
function handleStreamStart(data){
  const feed = document.getElementById('threadFeed');
  const agent = agentById(data.agent_id);
  const name = agent ? agent.name : data.agent_name || data.agent_id;
  const color = agent ? agent.color : '#8b949e';
  const avatarUrl = agent ? agent.avatar_url : '';
  if (!window._streamCounter) window._streamCounter = 0;
  const bubbleId = `stream-${data.agent_id}-${++window._streamCounter}`;
  const div = document.createElement('div');
  div.className = 'mu mu--thread mu--streaming';
  div.id = bubbleId;
  div.style.borderLeftColor = color;
  const avatarHtml = avatarUrl
    ? `<img src="${avatarUrl}" alt="${esc(name)}" style="width:24px;height:24px;border-radius:50%">`
    : `<div style="width:24px;height:24px;border-radius:50%;background:${color};display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:700;color:#fff">${esc(name.substring(0,2))}</div>`;
  // Build metadata tags
  const metaParts = [];
  if(data.pattern_type) metaParts.push(`<span class="mu__tag mu__tag--pattern">${data.pattern_type}</span>`);
  if(data.flow_step) metaParts.push(`<span class="mu__tag mu__tag--flow">${data.flow_step}</span>`);
  if(data.to_agent && data.to_agent !== 'all') {
    const toNames = data.to_agent.split(',').map(id => { const a = agentById(id.trim()); return a ? a.name.split(' ')[0] : id; });
    metaParts.push(`<span class="mu__tag mu__tag--to">→ ${toNames.join(', ')}</span>`);
  } else if(data.to_agent === 'all') {
    metaParts.push(`<span class="mu__tag mu__tag--to">→ Équipe</span>`);
  }
  const metaHtml = metaParts.length ? `<div class="mu__tags">${metaParts.join(' ')}</div>` : '';
  div.innerHTML = `
    <div class="mu__avatar" style="background:${color}20;border-color:${color}">${avatarHtml}</div>
    <div class="mu__body">
      <div class="mu__meta">
        <span class="mu__name" style="color:${color}">${esc(name)}</span>
        ${agent&&agent.role ? `<span class="mu__role">${esc(agent.role)}</span>` : ''}
        <span class="mu__typing"><span class="mu__dots"><span></span><span></span><span></span></span></span>
      </div>
      ${metaHtml}
      <div class="mu__content md-rendered mu__stream-content"></div>
    </div>`;
  feed.appendChild(div);
  feed.scrollTop = feed.scrollHeight;
  _streamBuffers[data.agent_id] = {div, content: '', bubbleId};
  updateNodeStatus({from_agent: data.agent_id, type: 'thinking'});
}

function handleStreamDelta(data){
  const buf = _streamBuffers[data.agent_id];
  if(!buf) return;
  buf.content += data.delta;
  buf.div.querySelector('.mu__stream-content').innerHTML = md(buf.content);
  const feed = document.getElementById('threadFeed');
  feed.scrollTop = feed.scrollHeight;
}

function handleStreamEnd(data){
  const buf = _streamBuffers[data.agent_id];
  if(buf && data.content) {
    buf.div.querySelector('.mu__stream-content').innerHTML = md(data.content);
    const typing = buf.div.querySelector('.mu__typing');
    if(typing) typing.remove();
    buf.div.classList.remove('mu--streaming');
  }
  delete _streamBuffers[data.agent_id];
  // Also push to other views
  if(data.content) {
    appendChatPanel({from_agent: data.agent_id, content: data.content, msg_type: 'text', type: 'text'});
    appendGraphLog({from_agent: data.agent_id, content: data.content, type: 'text'});
  }
  updateNodeStatus({from_agent: data.agent_id, type: 'idle'});
}

/* ── Append message to all modes ── */
function appendMessage(data){
  appendThread(data);
  appendChatPanel(data);
  appendGraphLog(data);
  appendChatBubble(data);
}

/* Thread mode — unified component */
function appendThread(data){
  const feed = document.getElementById('threadFeed');
  const agent = agentById(data.from_agent);
  const target = agentById(data.to_agent);
  const mtype = data.msg_type||data.type||'inform';
  const isUser = data.from_agent === 'user' || data.from_agent === 'human';
  const isSystem = data.from_agent === 'system' || mtype === 'system';
  const borderColors = {request:'var(--yellow)',delegate:'var(--yellow)',delegation:'var(--yellow)',response:'var(--green)',approve:'var(--green)',veto:'var(--red)',negotiate:'var(--blue)',inform:'#6b7280',system:'#6b7280',human_request:'var(--purple)',human_response:'var(--purple)'};
  const badgeStyles = {delegate:'background:rgba(59,130,246,.15);color:var(--blue)',veto:'background:var(--red);color:#fff',approve:'background:var(--green);color:#fff',request:'background:var(--yellow);color:#111',negotiate:'background:var(--blue);color:#fff'};
  const color = agent ? agent.color : '#8b949e';
  const icon = agent ? (agent.icon || 'bot') : 'bot';
  const name = isUser ? 'You' : (agent ? agent.name : data.from_agent);
  const targetName = target ? target.name : (data.to_agent || 'all');

  if (isSystem) {
    const d = document.createElement('div');
    d.className = 'mu mu--system';
    d.innerHTML = `<div class="mu__sys-text">${esc(data.content)}</div>`;
    feed.appendChild(d);
    return;
  }

  const div = document.createElement('div');
  div.className = 'mu mu--thread';
  div.style.borderLeftColor = borderColors[mtype] || 'transparent';
  const avatarInner = agent && agent.avatar_url
    ? `<img src="${agent.avatar_url}" alt="${esc(name)}" class="mu__photo">`
    : `<svg class="icon icon-sm" style="color:${color}"><use href="#icon-${icon}"/></svg>`;
  const avatarHtml = isUser
    ? `<div class="mu__avatar mu__avatar--user">You</div>`
    : `<div class="mu__avatar" style="background:${color}20;border-color:${color}">${avatarInner}</div>`;
  const badgeHtml = !['response','inform',''].includes(mtype) ? `<span class="mu__badge" style="${badgeStyles[mtype]||''}">${esc(mtype.toUpperCase())}</span>` : '';
  const roleHtml = agent && agent.role ? `<span class="mu__role">${esc(agent.role)}</span>` : '';
  const patternHtml = data.pattern_type ? `<span class="mu__pattern">(${esc(data.pattern_type)})</span>` : '';
  let targetHtml = '';
  if (data.to_agent && !['user','session',''].includes(data.to_agent)) {
    const tPhoto = target && target.avatar_url ? `<img src="${target.avatar_url}" alt="${esc(targetName)}" class="mu__target-photo">` : '';
    const tRole = target && target.role ? `<span class="mu__target-role">${esc(target.role)}</span>` : '';
    targetHtml = `<span class="mu__arrow">→</span>${tPhoto}<span class="mu__target" style="color:${target?target.color:'#6e6e6e'}">${esc(targetName)}</span>${tRole}`;
  }
  div.innerHTML = `
    ${avatarHtml}
    <div class="mu__body">
      <div class="mu__meta">
        <span class="mu__name" style="color:${isUser?'var(--green)':color}">${esc(name)}</span>
        ${roleHtml}${badgeHtml}${patternHtml}${targetHtml}
        <span class="mu__time mu__time--right">now</span>
      </div>
      <div class="mu__content md-rendered">${md(data.content)}</div>
    </div>`;
  feed.appendChild(div);
  feed.scrollTop = feed.scrollHeight;
}

/* Chat panel (right side) */
function appendChatPanel(data){
  const feed = document.getElementById('panelFeed');
  const agent = agentById(data.from_agent);
  const type = data.msg_type||data.type||'inform';
  const div = document.createElement('div');
  div.className = 'panel-msg';
  div.dataset.type = type;
  div.innerHTML = `
    <div class="panel-avatar" style="background:${agent?agent.color:'#6b7280'}">${agent?agent.avatar:'?'}</div>
    <div class="panel-body">
      <div class="panel-meta">
        <span>${esc(agent?agent.name:data.from_agent)}</span>
        <span class="panel-badge thread-badge--${type}">${esc(type)}</span>
      </div>
      <div class="panel-content">${esc((data.content||'').substring(0,120))}</div>
    </div>`;
  feed.appendChild(div);
  feed.scrollTop = feed.scrollHeight;
}

/* Chat bubble (left side, filtered by selected agent) */
function appendChatBubble(data){
  const sel = document.getElementById('chatAgentSelect').value;
  const isFromAgent = data.from_agent === sel;
  const isToAgent = data.to_agent === sel || !data.to_agent;
  const isHuman = data.from_agent === 'human' || data.from_agent === 'user';
  if(!isFromAgent && !isToAgent && !isHuman) return;

  const cont = document.getElementById('chatMessages');
  const agent = agentById(data.from_agent);
  const isUser = isHuman;
  const div = document.createElement('div');
  div.className = `chat-bubble chat-bubble--${isUser?'user':'agent'}`;
  div.innerHTML = `
    <div class="chat-bubble-meta">
      <span class="chat-bubble-name">${isUser?'You':esc(agent?agent.name:data.from_agent)}</span>
      <span class="chat-bubble-time">now</span>
    </div>
    <div class="chat-bubble-text md-rendered">${md(data.content)}</div>`;
  cont.appendChild(div);
  cont.scrollTop = cont.scrollHeight;
}

/* Graph log */
function appendGraphLog(data){
  const log = document.getElementById('graphLog');
  const agent = agentById(data.from_agent);
  const target = agentById(data.to_agent);
  const type = data.msg_type||data.type||'inform';
  const prefix = type==='veto'?'[VETO] ':type==='approve'?'[OK] ':'';
  const div = document.createElement('div');
  div.className = 'graph-log-line';
  div.innerHTML = `
    <span class="graph-log-time">${new Date().toLocaleTimeString()}</span>
    <span class="graph-log-from">${agent?agent.avatar:'?'} ${esc(agent?agent.name:data.from_agent)}</span>
    <span class="graph-log-arrow">→</span>
    <span class="graph-log-to">${esc(target?target.name:(data.to_agent||'all'))}</span>
    <span class="graph-log-content" data-type="${type}">${prefix}${esc((data.content||'').substring(0,100))}</span>`;
  log.insertBefore(div, document.getElementById('graphNewBtn'));
  if(log.scrollTop + log.clientHeight >= log.scrollHeight - 50){
    log.scrollTop = log.scrollHeight;
  } else {
    document.getElementById('graphNewBtn').style.display = 'block';
  }

  // Animate edge in graph
  if(data.from_agent && data.to_agent) animateEdge(data.from_agent, data.to_agent);
}

function scrollGraphLog(){
  const log = document.getElementById('graphLog');
  log.scrollTop = log.scrollHeight;
  document.getElementById('graphNewBtn').style.display = 'none';
}

/* ── Panel filters ── */
document.querySelectorAll('.panel-filter').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.panel-filter').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const filter = btn.dataset.filter;
    document.querySelectorAll('.panel-msg').forEach(m=>{
      if(filter==='all'){ m.style.display=''; return; }
      const t = m.dataset.type;
      if(filter==='decisions') m.style.display=(t==='approve'||t==='veto'||t==='delegate')?'':'none';
      else if(filter==='errors') m.style.display=(t==='veto'||t==='error')?'':'none';
    });
  });
});

/* ── Agent Dropdown (custom selects with photos) ── */
function initAgentDropdown(dropdownId, triggerId, menuId, hiddenId, onChange) {
  const dropdown = document.getElementById(dropdownId);
  const trigger = document.getElementById(triggerId);
  const menu = document.getElementById(menuId);
  const hidden = document.getElementById(hiddenId);
  if (!dropdown || !trigger || !menu) return;

  trigger.addEventListener('click', (e) => {
    e.stopPropagation();
    // Close other dropdowns
    document.querySelectorAll('.agent-dropdown.open').forEach(d => {
      if (d !== dropdown) d.classList.remove('open');
    });
    dropdown.classList.toggle('open');
  });

  menu.querySelectorAll('.agent-dropdown__item').forEach(item => {
    item.addEventListener('click', () => {
      const val = item.dataset.value;
      if (hidden) hidden.value = val;
      // Update trigger content from selected item
      const photo = item.querySelector('.agent-dropdown__photo');
      const initials = item.querySelector('.agent-dropdown__initials');
      const name = item.querySelector('.agent-dropdown__name');
      const role = item.querySelector('.agent-dropdown__role');
      const icon = item.querySelector('.icon');
      let triggerHTML = '';
      if (photo) triggerHTML += `<img src="${photo.src}" alt="" class="agent-dropdown__photo">`;
      else if (initials) triggerHTML += initials.outerHTML;
      else if (icon) triggerHTML += icon.outerHTML;
      triggerHTML += `<span class="agent-dropdown__name">${name ? name.textContent : ''}</span>`;
      if (role && role.textContent.trim()) triggerHTML += `<span class="agent-dropdown__role">${role.textContent}</span>`;
      triggerHTML += `<svg class="icon icon-xs agent-dropdown__chevron"><use href="#icon-chevron-down"/></svg>`;
      trigger.innerHTML = triggerHTML;
      // Mark active
      menu.querySelectorAll('.agent-dropdown__item').forEach(i => i.classList.remove('active'));
      item.classList.add('active');
      dropdown.classList.remove('open');
      if (onChange) onChange(val);
    });
  });
}

// Close dropdowns on outside click
document.addEventListener('click', () => {
  document.querySelectorAll('.agent-dropdown.open').forEach(d => d.classList.remove('open'));
});

// Init both dropdowns
initAgentDropdown('chatAgentDropdown', 'chatAgentTrigger', 'chatAgentMenu', 'chatAgentSelect', () => {
  document.getElementById('chatMessages').innerHTML = '';
});
initAgentDropdown('targetAgentDropdown', 'targetAgentTrigger', 'targetAgentMenu', 'targetAgent');

/* ── Graph rendering ── */
let graphNodes = GRAPH.nodes || [];
let graphEdges = GRAPH.edges || [];
let highlightedNode = null;
let focusedNode = null; // for dim/focus mode

/* ── Pan & Zoom state ── */
let zoomLevel = 1;
const ZOOM_MIN = 0.3, ZOOM_MAX = 3, ZOOM_STEP = 0.15;
let panX = 0, panY = 0;
let isPanning = false, panStartX = 0, panStartY = 0, panStartPX = 0, panStartPY = 0;
let graphW = 800, graphH = 500; // full content size

function applyViewTransform(){
  const svgEl = document.getElementById('liveSvg');
  if(!svgEl) return;
  svgEl.style.transform = `translate(${panX}px,${panY}px) scale(${zoomLevel})`;
  document.getElementById('zoomLevel').textContent = Math.round(zoomLevel*100)+'%';
  updateMinimap();
}

// Wheel zoom
document.getElementById('graphCanvas').addEventListener('wheel', e=>{
  if(activeTab!=='graph') return;
  e.preventDefault();
  const canvas = document.getElementById('graphCanvas');
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const oldZ = zoomLevel;
  zoomLevel = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, zoomLevel + (e.deltaY < 0 ? ZOOM_STEP : -ZOOM_STEP)));
  const ratio = zoomLevel / oldZ;
  panX = mx - ratio * (mx - panX);
  panY = my - ratio * (my - panY);
  applyViewTransform();
}, {passive:false});

// Mouse drag pan
const graphCanvas = document.getElementById('graphCanvas');
graphCanvas.addEventListener('mousedown', e=>{
  if(e.target.closest('.live-node,.node-tooltip,.agent-chat-panel,.graph-legend,.graph-zoom-controls,.graph-minimap')) return;
  isPanning = true;
  panStartX = e.clientX; panStartY = e.clientY;
  panStartPX = panX; panStartPY = panY;
  graphCanvas.classList.add('panning');
});
window.addEventListener('mousemove', e=>{
  if(!isPanning) return;
  panX = panStartPX + (e.clientX - panStartX);
  panY = panStartPY + (e.clientY - panStartY);
  applyViewTransform();
});
window.addEventListener('mouseup', ()=>{
  isPanning = false;
  graphCanvas.classList.remove('panning');
});

// Zoom buttons
document.getElementById('zoomIn').addEventListener('click', ()=>{ zoomLevel = Math.min(ZOOM_MAX, zoomLevel + ZOOM_STEP); applyViewTransform(); });
document.getElementById('zoomOut').addEventListener('click', ()=>{ zoomLevel = Math.max(ZOOM_MIN, zoomLevel - ZOOM_STEP); applyViewTransform(); });
document.getElementById('zoomFit').addEventListener('click', ()=>{
  const canvas = document.getElementById('graphCanvas');
  if(!graphNodes.length) return;
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  graphNodes.forEach(n=>{minX=Math.min(minX,n.x);minY=Math.min(minY,n.y);maxX=Math.max(maxX,n.x+NODE_W);maxY=Math.max(maxY,n.y+NODE_H)});
  const cw = canvas.clientWidth, ch = canvas.clientHeight - 20;
  const sw = (maxX-minX+80), sh = (maxY-minY+80);
  zoomLevel = Math.min(ZOOM_MAX, Math.min(cw/sw, ch/sh));
  panX = (cw - sw*zoomLevel)/2 - minX*zoomLevel + 40*zoomLevel;
  panY = (ch - sh*zoomLevel)/2 - minY*zoomLevel + 40*zoomLevel;
  applyViewTransform();
});

function renderGraph(){
  const canvas = document.getElementById('graphCanvas');
  const svgEl = document.getElementById('liveSvg');
  const W = canvas.clientWidth || 800;
  const baseH = canvas.clientHeight || 500;
  if(graphNodes.length && graphNodes[0].x == null) autoLayoutGraph(W, baseH);

  let maxY = baseH, maxX = W;
  graphNodes.forEach(n => {
    if(n.y != null) maxY = Math.max(maxY, n.y + NODE_H + 40);
    if(n.x != null) maxX = Math.max(maxX, n.x + NODE_W + 40);
  });
  graphW = maxX; graphH = maxY;
  svgEl.setAttribute('viewBox', `0 0 ${graphW} ${graphH}`);
  svgEl.style.width = graphW + 'px';
  svgEl.style.height = graphH + 'px';

  document.getElementById('livePhases').innerHTML = '';
  renderLiveEdges(graphW, graphH);
  renderLiveNodes();
  updateMinimap();
  // Show minimap only for larger graphs
  document.getElementById('graphMinimap').style.display = graphNodes.length > 6 ? '' : 'none';
}

function autoLayoutGraph(W, H){
  const N = graphNodes.length;
  if(!N) return;

  // Sort by hierarchy_rank (lower = higher in org chart)
  const sorted = graphNodes.slice().sort((a,b)=> (a.hierarchy_rank||50) - (b.hierarchy_rank||50));

  // Group into layers by rank
  const layerMap = new Map();
  sorted.forEach(n => {
    const rank = n.hierarchy_rank || 50;
    if(!layerMap.has(rank)) layerMap.set(rank, []);
    layerMap.get(rank).push(n);
  });
  const layers = [...layerMap.values()];

  // Position each layer
  const layerGap = Math.min(160, (H - 80) / (layers.length || 1));
  layers.forEach((layer, li)=>{
    const y = 30 + li * layerGap;
    const gap = Math.min(210, (W - 40) / (layer.length || 1));
    const startX = Math.max(20, (W - gap*(layer.length-1) - NODE_W) / 2);
    layer.forEach((n, i)=>{
      n.x = startX + i * gap;
      n.y = y;
    });
  });
}

function renderLiveEdges(W, H){
  const el = document.getElementById('liveEdges');
  el.innerHTML = '';

  // Pattern colors and styles (matching the Agentic Architectures reference)
  const PATTERN_STYLES = {
    sequential:   {color:'#3b82f6', dash:'',          icon:'→',  label:'Sequential'},
    hierarchical: {color:'#f59e0b', dash:'',          icon:'⬡',  label:'Hierarchical'},
    parallel:     {color:'#10b981', dash:'6 3',       icon:'⇉',  label:'Parallel'},
    loop:         {color:'#ec4899', dash:'4 4',       icon:'↻',  label:'Loop'},
    network:      {color:'#8b5cf6', dash:'2 4 8 4',   icon:'⬡',  label:'Network'},
    report:       {color:'#ef4444', dash:'3 3',       icon:'↩',  label:'Report'},
  };
  const DEFAULT_STYLE = {color:'#6b7280', dash:'', icon:'·', label:'Unknown'};

  // Track which patterns are active (for legend)
  const activePatterns = new Set();

  graphEdges.forEach(e=>{
    const fn = graphNodes.find(n=> n.agent_id===e.from);
    const tn = graphNodes.find(n=> n.agent_id===e.to);
    if(!fn || !tn) return;

    const x1 = fn.x + NODE_W/2, y1_base = fn.y + NODE_H;
    const x2 = tn.x + NODE_W/2, y2_base = tn.y;

    // Check if reverse edge exists (bidirectional)
    const hasReverse = graphEdges.some(re=> re.from===e.to && re.to===e.from);
    const offset = hasReverse ? 12 : 0;

    // Determine start/end points based on relative position
    let x1f, y1f, x2f, y2f;
    const dy = tn.y - fn.y;
    const dx = tn.x - fn.x;

    if(Math.abs(dy) < NODE_H * 0.8){
      if(dx > 0){
        x1f = fn.x + NODE_W; y1f = fn.y + NODE_H/2 - offset;
        x2f = tn.x;           y2f = tn.y + NODE_H/2 + offset;
      } else {
        x1f = fn.x;           y1f = fn.y + NODE_H/2 - offset;
        x2f = tn.x + NODE_W;  y2f = tn.y + NODE_H/2 + offset;
      }
      const midY = Math.min(y1f, y2f) - 40;
      var d = `M${x1f},${y1f} C${x1f},${midY} ${x2f},${midY} ${x2f},${y2f}`;
    } else if(dy > 0){
      x1f = x1 + offset; y1f = y1_base;
      x2f = x2 - offset; y2f = y2_base;
      const curveOff = Math.max(30, Math.abs(y2f-y1f)*0.3);
      var d = `M${x1f},${y1f} C${x1f},${y1f+curveOff} ${x2f},${y2f-curveOff} ${x2f},${y2f}`;
    } else {
      x1f = x1 - offset; y1f = fn.y;
      x2f = x2 + offset; y2f = tn.y + NODE_H;
      const curveOff = Math.max(30, Math.abs(y2f-y1f)*0.3);
      var d = `M${x1f},${y1f} C${x1f},${y1f-curveOff} ${x2f},${y2f+curveOff} ${x2f},${y2f}`;
    }

    // Determine pattern style — use dominant pattern (first one)
    const mainPattern = (e.patterns && e.patterns[0]) || '';
    const style = PATTERN_STYLES[mainPattern] || DEFAULT_STYLE;
    if(mainPattern) activePatterns.add(mainPattern);
    // Use explicit color from workflow config if provided
    const edgeColor = e.color || style.color;

    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d', d);
    path.setAttribute('class','edge-line');
    path.style.stroke = edgeColor;
    path.style.markerEnd = `url(#arrow-${mainPattern || 'default'})`;
    if(style.dash) path.style.strokeDasharray = style.dash;
    // Brighter when messages have flowed, dimmer when no activity yet
    path.style.opacity = e.count > 0 ? Math.min(0.9, 0.5 + e.count * 0.1).toFixed(2) : '0.35';
    path.style.strokeWidth = e.count > 0 ? Math.min(3.5, 1.5 + e.count * 0.3).toFixed(1) + 'px' : '1.2px';
    path.dataset.from = e.from;
    path.dataset.to = e.to;
    path.dataset.pattern = mainPattern;
    el.appendChild(path);

    // Label or count badge at midpoint
    const mx = (x1f + x2f) / 2;
    const my = (y1f + y2f) / 2 - 6;
    const badge = document.createElementNS('http://www.w3.org/2000/svg','text');
    badge.setAttribute('class','edge-count');
    badge.setAttribute('x', mx);
    badge.setAttribute('y', my);
    badge.style.fill = edgeColor;
    const typeIcons = (e.types||[]).map(t=> t==='veto'?'✗':t==='approve'?'✓':'').filter(Boolean).join('');
    const label = e.label || '';
    badge.textContent = e.count > 0
      ? `${label?label+' ':''}×${e.count}${typeIcons?' '+typeIcons:''}`
      : label || '';
    el.appendChild(badge);
  });

  // Build legend from active patterns
  const legendItems = document.querySelector('.graph-legend-items');
  if(legendItems){
    legendItems.innerHTML = '';
    const patternsToShow = activePatterns.size > 0
      ? [...activePatterns]
      : Object.keys(PATTERN_STYLES);
    patternsToShow.forEach(p => {
      const s = PATTERN_STYLES[p];
      if(!s) return;
      const item = document.createElement('div');
      item.className = 'graph-legend-item';
      item.innerHTML = `
        <span class="graph-legend-icon">${s.icon}</span>
        <svg width="36" height="12" class="graph-legend-line">
          <line x1="0" y1="6" x2="26" y2="6" stroke="${s.color}" stroke-width="2.5"
                ${s.dash ? `stroke-dasharray="${s.dash}"` : ''}/>
          <polygon points="26,2 34,6 26,10" fill="${s.color}" opacity="0.8"/>
        </svg>
        <span>${s.label}</span>
      `;
      legendItems.appendChild(item);
    });
    // Show legend only if there are patterns
    document.getElementById('graphLegend').style.display = patternsToShow.length ? '' : 'none';
  }
}

function renderLiveNodes(){
  const nl = document.getElementById('liveNodes');
  nl.innerHTML = '';

  // Compute connected set for focus mode
  let connectedSet = null;
  if(focusedNode){
    connectedSet = new Set([focusedNode]);
    graphEdges.forEach(e=>{
      if(e.from===focusedNode) connectedSet.add(e.to);
      if(e.to===focusedNode) connectedSet.add(e.from);
    });
  }

  graphNodes.forEach(n=>{
    const agId = n.agent_id || n.id;
    const agent = agentById(agId);
    const col = (agent && agent.color) || 'var(--purple)';
    const name = esc(agent ? agent.name : (n.label || n.id));
    const emoji = '';  // Use initials, not emoji
    const role = esc(agent ? agent.role : (n.role || ''));
    const status = (agent && agent.status) || n.status || 'idle';
    const sel = agId === highlightedNode;
    const isDimmed = connectedSet && !connectedSet.has(agId);
    const skillCount = agent ? (agent.skills||[]).length : 0;
    const toolCount = agent ? (agent.tools||[]).length : 0;

    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('class', 'live-node' + (sel?' highlight':'') + (isDimmed?' dimmed':''));
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    g.dataset.agent = agId;

    // Skill tags (show first 3)
    let skillTags = '';
    if(agent && agent.skills && agent.skills.length > 0){
      const shown = agent.skills.slice(0,3);
      const more = agent.skills.length > 3 ? ` +${agent.skills.length-3}` : '';
      skillTags = shown.map((s,i)=>`<text class="live-node-skill-tag" x="${14 + i*58}" y="${NODE_H-18}">${esc(s.substring(0,8))}</text>`).join('');
      if(more) skillTags += `<text class="live-node-skill-tag" x="${14 + shown.length*58}" y="${NODE_H-18}">${more}</text>`;
    }

    const avatarUrl = agent ? agent.avatar_url : '';
    const avatarR = 20;
    const avatarCx = 28, avatarCy = 36;
    const avatarSvg = avatarUrl
      ? `<clipPath id="clip-${n.id}"><circle cx="${avatarCx}" cy="${avatarCy}" r="${avatarR}"/></clipPath>
         <image href="${avatarUrl}" x="${avatarCx-avatarR}" y="${avatarCy-avatarR}" width="${avatarR*2}" height="${avatarR*2}" clip-path="url(#clip-${n.id})"/>`
      : `<circle cx="${avatarCx}" cy="${avatarCy}" r="${avatarR}" fill="${col}" opacity="0.25"/>
         <text x="${avatarCx}" y="${avatarCy+5}" text-anchor="middle" style="font-size:16px;fill:${col};font-weight:700">${emoji||name.substring(0,2)}</text>`;

    const tagline = agent ? (agent.tagline || agent.description || '') : '';
    const textX = avatarCx + avatarR + 12;

    // Pulse ring for thinking/acting agents
    const pulseRing = (status==='thinking'||status==='acting')
      ? `<circle class="pulse-ring" cx="${NODE_W-16}" cy="18" r="24" stroke="${status==='thinking'?'var(--yellow)':'var(--green)'}" />`
      : '';

    g.innerHTML = `
      <rect class="live-node-bg" width="${NODE_W}" height="${NODE_H}" ${sel?`style="stroke:${col};stroke-width:2.5"`:''} />
      <line class="live-node-bar" x1="0" y1="0" x2="${NODE_W}" y2="0" stroke="${col}" stroke-width="4"/>
      ${avatarSvg}
      <text class="live-node-name" x="${textX}" y="26">${name.length>18?name.substring(0,17)+'…':name}</text>
      <text class="live-node-role" x="${textX}" y="40">${role.length>24?role.substring(0,23)+'…':role}</text>
      ${tagline ? `<text class="live-node-tagline" x="${textX}" y="54">${esc(tagline.substring(0,30))}${tagline.length>30?'…':''}</text>` : ''}
      ${pulseRing}
      <circle class="node-status node-status--${status}" cx="${NODE_W-16}" cy="18" r="5"/>
      <text class="live-node-status-label" x="${NODE_W-16}" y="36" text-anchor="middle">${status}</text>
      ${skillCount||toolCount ? `<text class="live-node-meta" x="14" y="${NODE_H-10}">${toolCount}T ${skillCount}S</text>` : ''}
      ${skillTags}
    `;
    g.addEventListener('click', (e)=> { e.stopPropagation(); onNodeClick(n, g); });
    nl.appendChild(g);
  });

  // Dim/un-dim edges to match focused node
  document.querySelectorAll('#liveEdges .edge-line').forEach(path=>{
    if(connectedSet){
      const edgeConnected = connectedSet.has(path.dataset.from) && connectedSet.has(path.dataset.to);
      path.classList.toggle('dimmed', !edgeConnected);
    } else {
      path.classList.remove('dimmed');
    }
  });
  document.querySelectorAll('#liveEdges .edge-count').forEach(txt=>{
    // edge-count badges sit right after their paths — dim based on sibling path
    const prevPath = txt.previousElementSibling;
    if(prevPath) txt.classList.toggle('dimmed', prevPath.classList.contains('dimmed'));
  });
}

function onNodeClick(node, gEl){
  const agentId = node.agent_id || node.id;

  // Toggle focus mode (dim unconnected nodes)
  if(focusedNode === agentId){
    focusedNode = null;
    highlightedNode = null;
  } else {
    focusedNode = agentId;
    highlightedNode = agentId;
  }
  renderLiveNodes();

  // Open agent chat panel
  if(focusedNode){
    openAgentChat(agentId);
  } else {
    closeAgentChat();
  }

  // Also show the tooltip briefly
  const tooltip = document.getElementById('nodeTooltip');
  if(!highlightedNode){ tooltip.classList.remove('visible'); return; }

  const agent = agentById(agentId);
  const status = agent ? agent.status : 'unknown';
  const statusCls = status==='thinking'?'dot--thinking':status==='acting'?'dot--active':status==='error'?'dot--error':'';
  const statusDot = `<span class="dot ${statusCls}" style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${status==='thinking'?'var(--yellow)':status==='acting'?'var(--green)':status==='error'?'var(--red)':'#6b7280'}"></span>`;

  // Skills section
  let skillsHtml = '';
  if(agent && agent.skills && agent.skills.length){
    skillsHtml = `<div class="node-tooltip-section">
      <div class="node-tooltip-section-title"><svg class="icon icon-xs" style="vertical-align:middle"><use href="#icon-layers"/></svg> Skills (${agent.skills.length})</div>
      <div class="node-tooltip-tags">${agent.skills.map(s=>`<span class="node-tooltip-tag node-tooltip-tag--skill">${esc(s)}</span>`).join('')}</div>
    </div>`;
  }

  // Tools section
  let toolsHtml = '';
  if(agent && agent.tools && agent.tools.length){
    toolsHtml = `<div class="node-tooltip-section">
      <div class="node-tooltip-section-title"><svg class="icon icon-xs" style="vertical-align:middle"><use href="#icon-settings"/></svg> Tools (${agent.tools.length})</div>
      <div class="node-tooltip-tags">${agent.tools.map(t=>`<span class="node-tooltip-tag ${t.startsWith('mcp:')?'node-tooltip-tag--mcp':'node-tooltip-tag--tool'}">${esc(t.startsWith('mcp:')?t.slice(4):t)}</span>`).join('')}</div>
    </div>`;
  }

  // MCPs section
  let mcpsHtml = '';
  if(agent && agent.mcps && agent.mcps.length){
    mcpsHtml = `<div class="node-tooltip-section">
      <div class="node-tooltip-section-title"><svg class="icon icon-xs" style="vertical-align:middle"><use href="#icon-plug"/></svg> MCPs (${agent.mcps.length})</div>
      <div class="node-tooltip-tags">${agent.mcps.map(m=>`<span class="node-tooltip-tag node-tooltip-tag--mcp">${esc(m)}</span>`).join('')}</div>
    </div>`;
  }

  // Model section
  let modelHtml = '';
  if(agent && (agent.model || agent.provider)){
    modelHtml = `<div class="node-tooltip-section">
      <div class="node-tooltip-section-title"><svg class="icon icon-xs" style="vertical-align:middle"><use href="#icon-brain"/></svg> LLM</div>
      <span class="node-tooltip-tag">${esc(agent.provider||'')} ${esc(agent.model||'default')}</span>
    </div>`;
  }

  // Description
  let descHtml = '';
  if(agent && agent.description){
    descHtml = `<div class="node-tooltip-desc">${esc(agent.description)}</div>`;
  }

  const tooltipAvatar = agent && agent.avatar_url
    ? `<img src="${agent.avatar_url}" style="width:40px;height:40px;border-radius:50%;flex-shrink:0">`
    : `<span class="node-tooltip-avatar">${agent?agent.avatar:''}</span>`;
  tooltip.innerHTML = `
    <button class="node-tooltip-close" onclick="document.getElementById('nodeTooltip').classList.remove('visible');highlightedNode=null;renderLiveNodes();"><svg class="icon icon-xs"><use href="#icon-x"/></svg></button>
    <div class="node-tooltip-header">
      ${tooltipAvatar}
      <div class="node-tooltip-info">
        <div class="node-tooltip-name">${esc(agent?agent.name:agentId)}</div>
        <div class="node-tooltip-role">${esc(agent?agent.role:'')}</div>
      </div>
      <span class="node-tooltip-status">${statusDot} ${status}</span>
    </div>
    ${agent && agent.tagline ? `<div class="node-tooltip-desc" style="font-style:italic;margin-bottom:0.3rem">${esc(agent.tagline)}</div>` : ''}
    ${agent && agent.persona ? `<div class="node-tooltip-section">
      <div class="node-tooltip-section-title"><svg class="icon icon-xs" style="vertical-align:middle;margin-right:0.2rem"><use href="#icon-user"/></svg> Persona</div>
      <div class="node-tooltip-desc" style="white-space:pre-line;max-height:120px;overflow-y:auto">${esc(agent.persona.substring(0, 300))}${agent.persona.length > 300 ? '…' : ''}</div>
    </div>` : ''}
    ${agent && agent.motivation ? `<div class="node-tooltip-section">
      <div class="node-tooltip-section-title"><svg class="icon icon-xs" style="vertical-align:middle;margin-right:0.2rem"><use href="#icon-zap"/></svg> Motivation</div>
      <div class="node-tooltip-desc" style="white-space:pre-line;max-height:80px;overflow-y:auto">${esc(agent.motivation)}</div>
    </div>` : ''}
    ${descHtml}
    ${skillsHtml}
    ${toolsHtml}
    ${mcpsHtml}
    ${modelHtml}
  `;

  // Position tooltip: prefer right of node, fallback left if overflow
  const canvas = document.getElementById('graphCanvas');
  const canvasW = canvas.clientWidth || 800;
  const tipW = 280;
  let tipX = node.x + NODE_W + 12;
  if(tipX + tipW > canvasW) tipX = Math.max(8, node.x - tipW - 12);
  tooltip.style.left = tipX + 'px';
  tooltip.style.top = Math.max(8, node.y) + 'px';
  tooltip.classList.add('visible');
}

// Close tooltip + chat panel when clicking canvas background
document.getElementById('graphCanvas').addEventListener('click', (e)=>{
  if(e.target.tagName === 'svg' || e.target.id === 'graphCanvas'){
    highlightedNode = null;
    focusedNode = null;
    document.getElementById('nodeTooltip').classList.remove('visible');
    closeAgentChat();
    renderLiveNodes();
  }
});

/* ── Graph status updates ── */
function updateNodeStatus(data){
  if(data.type === 'status' && data.from_agent){
    const agent = agentById(data.from_agent);
    if(agent) agent.status = data.status || 'idle';
    if(activeTab === 'graph') renderLiveNodes();
    // Update thinking indicator in chat
    updateThinking(data);
  }
}

function updateThinking(data){
  const existing = document.querySelector('.chat-thinking');
  if(data.status === 'thinking' && !existing){
    const cont = document.getElementById('chatMessages');
    const div = document.createElement('div');
    div.className = 'chat-thinking';
    div.innerHTML = `Thinking<span class="dots"><span>.</span><span>.</span><span>.</span></span>`;
    cont.appendChild(div);
    cont.scrollTop = cont.scrollHeight;
  } else if(data.status !== 'thinking' && existing){
    existing.remove();
  }
}

/* ── Edge animation with flow particle ── */
function animateEdge(fromId, toId){
  const edges = document.querySelectorAll('#liveEdges .edge-line');
  edges.forEach(path=>{
    if(path.dataset.from===fromId && path.dataset.to===toId){
      path.classList.add('edge-active');
      setTimeout(()=> path.classList.remove('edge-active'), 1200);
      // Spawn flow particle along the path
      spawnFlowParticle(path);
    }
  });
}

function spawnFlowParticle(pathEl){
  const svgEl = document.getElementById('liveSvg');
  const edgesGroup = document.getElementById('liveEdges');
  const pathD = pathEl.getAttribute('d');
  if(!pathD) return;
  const color = pathEl.style.stroke || 'var(--purple)';

  const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
  circle.setAttribute('r','5');
  circle.setAttribute('fill', color);
  circle.setAttribute('class','flow-particle');
  circle.style.filter = `drop-shadow(0 0 4px ${color})`;

  const anim = document.createElementNS('http://www.w3.org/2000/svg','animateMotion');
  anim.setAttribute('dur','0.8s');
  anim.setAttribute('repeatCount','1');
  anim.setAttribute('fill','freeze');
  const motionPath = document.createElementNS('http://www.w3.org/2000/svg','mpath');
  // Create a temporary path with the same d for the particle
  const tempPath = document.createElementNS('http://www.w3.org/2000/svg','path');
  const tempId = 'fp-' + Date.now() + Math.random().toString(36).slice(2,6);
  tempPath.setAttribute('id', tempId);
  tempPath.setAttribute('d', pathD);
  tempPath.style.display = 'none';
  edgesGroup.appendChild(tempPath);
  motionPath.setAttributeNS('http://www.w3.org/1999/xlink','href','#'+tempId);
  anim.appendChild(motionPath);
  circle.appendChild(anim);
  circle.classList.add('animate');
  svgEl.appendChild(circle);

  // Cleanup after animation
  setTimeout(()=>{
    circle.remove();
    tempPath.remove();
  }, 900);
}

/* ── Minimap ── */
function updateMinimap(){
  const minimapSvg = document.getElementById('minimapSvg');
  if(!minimapSvg || !graphNodes.length) return;
  const mmW = 160, mmH = 100;
  minimapSvg.setAttribute('viewBox', `0 0 ${graphW} ${graphH}`);

  let html = '';
  // Draw edges as thin lines
  graphEdges.forEach(e=>{
    const fn = graphNodes.find(n=> n.agent_id===e.from);
    const tn = graphNodes.find(n=> n.agent_id===e.to);
    if(!fn || !tn) return;
    html += `<line x1="${fn.x+NODE_W/2}" y1="${fn.y+NODE_H/2}" x2="${tn.x+NODE_W/2}" y2="${tn.y+NODE_H/2}" stroke="#6b7280" stroke-width="3" opacity="0.3"/>`;
  });
  // Draw nodes as small rects
  graphNodes.forEach(n=>{
    const agent = agentById(n.agent_id||n.id);
    const col = (agent&&agent.color)||'#6b7280';
    html += `<rect x="${n.x}" y="${n.y}" width="${NODE_W}" height="${NODE_H}" rx="6" fill="${col}" opacity="0.5"/>`;
  });
  // Viewport indicator
  const canvas = document.getElementById('graphCanvas');
  if(canvas){
    const vw = canvas.clientWidth / zoomLevel;
    const vh = canvas.clientHeight / zoomLevel;
    const vx = -panX / zoomLevel;
    const vy = -panY / zoomLevel;
    html += `<rect class="minimap-viewport" x="${vx}" y="${vy}" width="${vw}" height="${vh}"/>`;
  }
  minimapSvg.innerHTML = html;
}

// Click minimap to navigate
document.getElementById('graphMinimap').addEventListener('click', e=>{
  const mmSvg = document.getElementById('minimapSvg');
  const rect = mmSvg.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / rect.width * graphW;
  const my = (e.clientY - rect.top) / rect.height * graphH;
  const canvas = document.getElementById('graphCanvas');
  panX = -(mx - canvas.clientWidth/(2*zoomLevel)) * zoomLevel;
  panY = -(my - canvas.clientHeight/(2*zoomLevel)) * zoomLevel;
  applyViewTransform();
});

/* ── Agent Chat 1:1 Panel ── */
let chatAgentId = null;
const acPanel = document.getElementById('agentChatPanel');
const acMessages = document.getElementById('acMessages');
const acInput = document.getElementById('acInput');

function openAgentChat(agentId){
  chatAgentId = agentId;
  const agent = agentById(agentId);
  if(!agent) return;

  // Header
  const avEl = document.getElementById('acAvatar');
  if(agent.avatar_url){
    avEl.innerHTML = `<img src="${agent.avatar_url}" alt="${esc(agent.name)}">`;
    avEl.style.background = 'none';
  } else {
    avEl.innerHTML = agent.avatar || agentId.substring(0,2).toUpperCase();
    avEl.style.background = agent.color || '#6b7280';
  }
  document.getElementById('acName').textContent = agent.name || agentId;
  document.getElementById('acRole').textContent = agent.role || '';

  const status = agent.status || 'idle';
  const dot = document.getElementById('acStatusDot');
  dot.className = 'agent-chat-status-dot' + (status==='thinking'?' thinking':'') + (status==='acting'?' acting':'') + (status==='error'?' error':'');
  document.getElementById('acStatusText').textContent = status;

  // Skills
  const skillsEl = document.getElementById('acSkills');
  if(agent.skills && agent.skills.length){
    skillsEl.innerHTML = agent.skills.slice(0,8).map(s=>`<span class="agent-chat-skill">${esc(s)}</span>`).join('');
    skillsEl.style.display = '';
  } else {
    skillsEl.style.display = 'none';
  }

  // Load existing messages for this agent from graph log
  acMessages.innerHTML = '';
  // Filter: all messages involving this agent from the SSE history
  // (messages already in DOM are from server-rendered template — we start fresh)

  acPanel.classList.add('open');
  acInput.focus();
}

function closeAgentChat(){
  chatAgentId = null;
  acPanel.classList.remove('open');
}

document.getElementById('acClose').addEventListener('click', (e)=>{
  e.stopPropagation();
  focusedNode = null;
  highlightedNode = null;
  closeAgentChat();
  document.getElementById('nodeTooltip').classList.remove('visible');
  renderLiveNodes();
});

// Send message to agent
async function sendAgentChatMessage(content){
  if(!chatAgentId || !content.trim()) return;
  const text = content.trim();
  // Add user bubble
  addAgentChatBubble('user', 'You', text);
  acInput.value = '';
  // Show typing
  document.getElementById('acTyping').classList.add('visible');

  try{
    await fetch(`/api/sessions/${SESSION_ID}/agents/${chatAgentId}/message`, {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body:`content=${encodeURIComponent(text)}`
    });
  }catch(err){
    console.error('Agent chat send error:', err);
  }
}

function addAgentChatBubble(who, name, content){
  const div = document.createElement('div');
  div.className = `agent-chat-bubble agent-chat-bubble--${who==='user'?'user':'agent'}`;
  div.innerHTML = `
    <div class="agent-chat-bubble-meta">${esc(name)} · now</div>
    <div class="agent-chat-bubble-text">${md(content)}</div>`;
  acMessages.appendChild(div);
  acMessages.scrollTop = acMessages.scrollHeight;
}

document.getElementById('acSend').addEventListener('click', ()=> sendAgentChatMessage(acInput.value));
acInput.addEventListener('keydown', e=>{
  if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendAgentChatMessage(acInput.value); }
});

// Quick action buttons
document.querySelectorAll('.agent-chat-action').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const action = btn.dataset.action;
    const prompts = {
      status: 'What is your current status? What are you working on?',
      review: 'Please review the latest changes and give your assessment.',
      delegate: 'I need you to take on a new task. What is your current capacity?'
    };
    const text = prompts[action] || '';
    if(text) sendAgentChatMessage(text);
  });
});

// Route SSE messages to agent chat panel
function routeToAgentChat(data){
  if(!chatAgentId) return;
  const fromAgent = data.from_agent;
  const toAgent = data.to_agent;
  // Show message if it's from the chatted agent, or addressed to them from user
  if(fromAgent === chatAgentId){
    const agent = agentById(fromAgent);
    addAgentChatBubble('agent', agent?agent.name:fromAgent, data.content);
    document.getElementById('acTyping').classList.remove('visible');
  }
  // Update status dot
  if(data.type === 'status' && fromAgent === chatAgentId){
    const st = data.status || 'idle';
    const dot = document.getElementById('acStatusDot');
    dot.className = 'agent-chat-status-dot' + (st==='thinking'?' thinking':'') + (st==='acting'?' acting':'') + (st==='error'?' error':'');
    document.getElementById('acStatusText').textContent = st;
    // Typing indicator
    if(st==='thinking') document.getElementById('acTyping').classList.add('visible');
    else document.getElementById('acTyping').classList.remove('visible');
  }
}

/* ── Initial scroll ── */
const threadFeed = document.getElementById('threadFeed');
if(threadFeed) threadFeed.scrollTop = threadFeed.scrollHeight;
const graphLog = document.getElementById('graphLog');
if(graphLog) graphLog.scrollTop = graphLog.scrollHeight;

/* ── Resize handler ── */
let resizeTimer;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=>{ if(activeTab==='graph') renderGraph(); }, 200);
});

})();
</script>
{% endblock %}
