{% extends "base.html" %}

{% block topbar_actions %}
<div style="display:flex;align-items:center;gap:10px;">
    <span class="badge badge-purple" id="world-agent-count">{{ agents|length }} agents</span>
    <span class="badge badge-green" id="world-active-count">0 actifs</span>
    <span class="badge badge-blue" id="world-mission-count">0 missions</span>
    <button class="btn btn-sm" onclick="worldToggleDayNight()" title="{{ _("tt_day_night") }}" id="btn-daynight"><svg class="icon icon-sm"><use href="#icon-moon"/></svg></button>
    <button class="btn btn-sm" onclick="worldResetCamera()" title="Reset camera">
        <svg class="icon icon-sm"><use href="#icon-maximize"/></svg>
    </button>
</div>
{% endblock %}

{% block content %}
<style>
/* ── World Layout ── */
.world-wrap{position:relative;width:100%;height:calc(100vh - 56px);overflow:hidden;background:#151020}
#world-canvas{width:100%;height:100%;display:block}

/* ── HUD Overlay ── */
.world-hud{position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none;z-index:10}
.world-hud > *{pointer-events:auto}

/* ── Activity Feed ── */
.world-feed{position:absolute;right:12px;top:12px;width:280px;max-height:45vh;overflow-y:auto;display:flex;flex-direction:column;gap:4px;scrollbar-width:thin;scrollbar-color:var(--purple-light) transparent}
.world-feed::-webkit-scrollbar{width:4px}
.world-feed::-webkit-scrollbar-thumb{background:var(--purple-light);border-radius:4px}
.wf-item{background:rgba(15,13,26,0.85);backdrop-filter:blur(8px);border:1px solid rgba(124,58,237,0.2);border-radius:8px;padding:6px 10px;font-size:0.72rem;color:var(--text-secondary);display:flex;align-items:flex-start;gap:6px;animation:wf-in .3s ease}
@keyframes wf-in{from{opacity:0;transform:translateX(20px)}to{opacity:1;transform:translateX(0)}}
.wf-dot{width:6px;height:6px;border-radius:50%;margin-top:4px;flex-shrink:0}
.wf-dot--thinking{background:var(--yellow)}
.wf-dot--acting{background:var(--blue)}
.wf-dot--idle{background:var(--green)}
.wf-dot--error{background:var(--red)}
.wf-time{color:var(--text-muted);font-size:0.65rem;white-space:nowrap}
.wf-name{color:var(--purple-light);font-weight:600}

/* ── Agent Info Panel ── */
.world-info{position:absolute;left:12px;bottom:12px;width:320px;background:rgba(15,13,26,0.92);backdrop-filter:blur(12px);border:1px solid rgba(124,58,237,0.3);border-radius:12px;padding:16px;display:none;animation:wi-in .25s ease}
@keyframes wi-in{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.wi-header{display:flex;align-items:center;gap:10px;margin-bottom:10px}
.wi-avatar{width:40px;height:40px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:1.3rem;font-weight:700;color:#fff}
.wi-name{font-size:0.95rem;font-weight:700;color:var(--text-primary)}
.wi-role{font-size:0.72rem;color:var(--text-secondary)}
.wi-status{display:inline-flex;align-items:center;gap:4px;font-size:0.7rem;padding:2px 8px;border-radius:8px;background:var(--bg-tertiary)}
.wi-status .dot{width:6px;height:6px;border-radius:50%}
.wi-task{font-size:0.75rem;color:var(--text-secondary);margin-top:8px;padding:8px;background:var(--bg-tertiary);border-radius:8px;max-height:60px;overflow:hidden}
.wi-skills{display:flex;flex-wrap:wrap;gap:3px;margin-top:8px}
.wi-skill{font-size:0.62rem;padding:1px 6px;border-radius:4px;background:rgba(124,58,237,0.2);color:var(--purple-light)}
.wi-close{position:absolute;top:8px;right:8px;background:none;border:none;color:var(--text-secondary);cursor:pointer;font-size:1rem}

/* ── Zone Labels ── */
.world-zones{position:absolute;left:12px;top:12px;display:flex;flex-direction:column;gap:3px}
.wz-label{font-size:0.65rem;color:var(--text-muted);padding:2px 8px;border-radius:4px;background:rgba(15,13,26,0.7);border-left:3px solid;cursor:pointer;transition:all .15s}
.wz-label:hover{color:var(--text-primary);background:rgba(15,13,26,0.9)}

/* ── Loading ── */
.world-loading{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#151020;z-index:100;transition:opacity .5s}
.world-loading.hidden{opacity:0;pointer-events:none}
.world-loading h3{color:var(--purple-light);font-size:1.2rem;margin-bottom:8px}
.world-loading p{color:var(--text-secondary);font-size:0.8rem}
.wl-bar{width:200px;height:3px;background:var(--bg-tertiary);border-radius:3px;overflow:hidden;margin-top:12px}
.wl-fill{height:100%;background:var(--purple);border-radius:3px;width:0%;transition:width .3s}

/* ── Legend ── */
.world-legend{position:absolute;right:12px;bottom:12px;display:flex;gap:10px;background:rgba(15,13,26,0.85);padding:6px 12px;border-radius:8px;border:1px solid rgba(124,58,237,0.15)}
.wl-item{display:flex;align-items:center;gap:4px;font-size:0.62rem;color:var(--text-secondary)}
.wl-diamond{width:8px;height:8px;transform:rotate(45deg);border-radius:1px}
</style>

<div class="world-wrap">
    <!-- Loading screen -->
    <div class="world-loading" id="world-loading">
        <h3>{{ _("macaron_world") }}</h3>
        <p>{{ _("building_office") }}</p>
        <div class="wl-bar"><div class="wl-fill" id="world-load-bar"></div></div>
    </div>

    <!-- Three.js Canvas -->
    <canvas id="world-canvas"></canvas>

    <!-- HUD Overlay -->
    <div class="world-hud">
        <!-- Zone shortcuts -->
        <div class="world-zones" id="world-zones"></div>

        <!-- Activity feed -->
        <div class="world-feed" id="world-feed"></div>

        <!-- Agent info panel -->
        <div class="world-info" id="world-info">
            <button class="wi-close" onclick="worldDeselectAgent()">&times;</button>
            <div class="wi-header">
                <div class="wi-avatar" id="wi-avatar">G</div>
                <div>
                    <div class="wi-name" id="wi-name">—</div>
                    <div class="wi-role" id="wi-role">—</div>
                </div>
                <div class="wi-status" id="wi-status">
                    <span class="dot"></span> <span>{{ _("idle") }}</span>
                </div>
            </div>
            <div class="wi-task" id="wi-task" style="display:none"></div>
            <div class="wi-skills" id="wi-skills"></div>
        </div>

        <!-- Legend -->
        <div class="world-legend">
            <div class="wl-item"><div class="wl-diamond" style="background:#22c55e"></div> Idle</div>
            <div class="wl-item"><div class="wl-diamond" style="background:#eab308"></div> Thinking</div>
            <div class="wl-item"><div class="wl-diamond" style="background:#3b82f6"></div> Acting</div>
            <div class="wl-item"><div class="wl-diamond" style="background:#a855f7"></div> Waiting</div>
            <div class="wl-item"><div class="wl-diamond" style="background:#ef4444"></div> Error</div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ═══════════════════════════════════════════════════════════════
// MACARON WORLD — 3D Sims-like Agent Visualization
// ═══════════════════════════════════════════════════════════════

const AGENT_DATA = {{ agents_json|safe }};
const LIVE_DATA = {{ live_json|safe }};

// ── Day/Night Mode — synced with site theme ──
let isDayMode = (localStorage.getItem('macaron_theme') || 'dark') === 'light';
const THEMES = {
    night: { bg: 0x151020, fog: 0x151020, ambient: 0x6040a0, ambientI: 1.0, dirColor: 0xffeedd, dirI: 1.2,
             fillColor: 0xaabbff, fillI: 0.5, hemiSky: 0x9080d0, hemiGnd: 0x302540, hemiI: 0.6,
             floor: 0x1e1830, grid1: 0x302550, grid2: 0x251a40, exposure: 1.4 },
    day:   { bg: 0xb8d0e8, fog: 0xc8ddf0, ambient: 0xffffff, ambientI: 0.6, dirColor: 0xfffaf0, dirI: 1.8,
             fillColor: 0x8ebbff, fillI: 0.7, hemiSky: 0x87ceeb, hemiGnd: 0x8fbc8f, hemiI: 0.8,
             floor: 0xd5cfc2, grid1: 0xc0b8a8, grid2: 0xccc4b4, exposure: 1.0 },
};

// ── Dynamic Layout — Campus + Conveyors ──
const PHASE_W = 2.2;
const BLDG_PAD = 3;
const BLDG_DEPTH = 8;
const BLDG_GAP = 4;
const MISSION_COLORS = [0x3b82f6, 0x7c3aed, 0xf97316, 0x06b6d4, 0xef4444, 0x22c55e, 0xeab308, 0xec4899];

function generateLayout() {
    const missions = LIVE_DATA.missions || [];
    const mzones = [];
    // Sort: fewer phases first (pair small ones side-by-side)
    const sorted = missions.map((m, i) => ({...m, _i: i})).sort((a,b) => (a.phases?.length||0) - (b.phases?.length||0));
    let curZ = -28;
    let idx = 0;
    while (idx < sorted.length) {
        const m = sorted[idx];
        const bw = (m.phases?.length || 1) * PHASE_W + BLDG_PAD * 2;
        if (bw <= 18 && idx + 1 < sorted.length) {
            const m2 = sorted[idx + 1];
            const bw2 = (m2.phases?.length || 1) * PHASE_W + BLDG_PAD * 2;
            if (bw2 <= 18) {
                const gap = 4;
                mzones.push({ id:`mission-${m._i}`, name:m.name, mission:m, x:-(bw+gap)/2+bw/2, z:curZ, w:bw, h:BLDG_DEPTH, color:MISSION_COLORS[m._i%8], floorColor:0x152040, floorDay:0xd0d8e8, roles:[] });
                mzones.push({ id:`mission-${m2._i}`, name:m2.name, mission:m2, x:(bw2+gap)/2-bw2/2+gap/2, z:curZ, w:bw2, h:BLDG_DEPTH, color:MISSION_COLORS[m2._i%8], floorColor:0x152040, floorDay:0xd0d8e8, roles:[] });
                idx += 2; curZ += BLDG_DEPTH + BLDG_GAP; continue;
            }
        }
        mzones.push({ id:`mission-${m._i}`, name:m.name, mission:m, x:0, z:curZ, w:bw, h:BLDG_DEPTH, color:MISSION_COLORS[m._i%8], floorColor:0x152040, floorDay:0xd0d8e8, roles:[] });
        idx++; curZ += BLDG_DEPTH + BLDG_GAP;
    }
    // Shared zones on the right side
    const sx = Math.max(22, ...mzones.map(z => z.x + z.w/2)) + 6;
    const shared = [
        { id:'board', name:'Board Room', x:sx, z:-12, w:12, h:8, color:0xd4a017, floorColor:0x2a2010, floorDay:0xe8dcc0,
          roles:['dsi','cto','cpo','strat-cpo','strat-cto','lean_portfolio_manager','strat-portfolio','scrum_master','chef_projet','agile_coach','chef_de_programme','product_manager','epic_owner','solution_manager','enterprise_architect','solution_architect','cloud_architect','architecte','brain','product','tech_writer','pmo'] },
        { id:'chill', name:'Chill Zone', x:sx, z:4, w:12, h:10, color:0x84cc16, floorColor:0x182510, floorDay:0xd0e8c0, roles:[] },
    ];
    return { missionZones: mzones, shared, all: [...mzones, ...shared] };
}
const _layout = generateLayout();
const ZONES = _layout.all;
const MISSION_ZONES = _layout.missionZones;

const STATUS_COLORS = {
    idle:     0x22c55e,
    thinking: 0xeab308,
    acting:   0x3b82f6,
    waiting:  0xa855f7,
    blocked:  0xf97316,
    error:    0xef4444,
    stopped:  0x6b7280,
    paused:   0x6b7280,
};

// ── Globals ──
let scene, camera, renderer, controls, clock;
let agents = {};  // id → { mesh, data, target, status, walkPhase, ... }
let raycaster, mouse;
let selectedAgent = null;
let particleSystems = [];
// Day/Night scene references
let sceneRefs = { ambient: null, dir: null, fill: null, hemi: null, floor: null, grid: null, zoneMeshes: [], trees: [], skyDome: null, fountain: null, stars: null };

// ── Loading ──
const loadBar = document.getElementById('world-load-bar');
const loadScreen = document.getElementById('world-loading');
function setLoadProgress(pct) { loadBar.style.width = pct + '%'; }

// ═══════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════
function init() {
    setLoadProgress(10);
    const canvas = document.getElementById('world-canvas');

    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x151020);
    scene.fog = new THREE.FogExp2(0x151020, 0.004);

    // Camera — isometric-ish
    camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 250);
    camera.position.set(40, 35, 40);
    camera.lookAt(0, 0, 0);

    // Renderer
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;

    // Controls
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.maxPolarAngle = Math.PI / 2.2;
    controls.minDistance = 8;
    controls.maxDistance = 80;
    controls.target.set(0, 0, 0);

    // Clock
    clock = new THREE.Clock();

    // Raycaster
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    setLoadProgress(20);
    buildLighting();
    setLoadProgress(30);
    buildFloor();
    setLoadProgress(35);
    buildZones();
    setLoadProgress(40);
    buildMissionBuildings();
    setLoadProgress(50);
    buildSharedFurniture();
    setLoadProgress(60);
    buildNature();
    setLoadProgress(70);
    buildAgents();
    setLoadProgress(80);
    buildAmbientParticles();
    setLoadProgress(90);
    buildZoneLabelsUI();
    setupInteraction();
    connectSSE();
    seedLiveData();
    if (isDayMode) applyDayNight(true, false);
    document.getElementById('btn-daynight').innerHTML = isDayMode ? '<svg class="icon icon-sm"><use href="#icon-sun"/></svg>' : '<svg class="icon icon-sm"><use href="#icon-moon"/></svg>';

    // Listen for site theme changes (topbar toggle)
    new MutationObserver(() => {
        const siteTheme = document.documentElement.getAttribute('data-theme');
        const shouldBeDay = siteTheme === 'light';
        if (shouldBeDay !== isDayMode) {
            isDayMode = shouldBeDay;
            document.getElementById('btn-daynight').innerHTML = isDayMode ? '<svg class="icon icon-sm"><use href="#icon-sun"/></svg>' : '<svg class="icon icon-sm"><use href="#icon-moon"/></svg>';
            applyDayNight(isDayMode, true);
        }
    }).observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    setLoadProgress(100);
    setTimeout(() => loadScreen.classList.add('hidden'), 400);

    // Resize
    window.addEventListener('resize', onResize);
    window.worldResetCamera = resetCamera;
    window.worldDeselectAgent = deselectAgent;
    window.worldToggleDayNight = toggleDayNight;

    animate();
}

// ═══════════════════════════════════════════════════════
// LIGHTING
// ═══════════════════════════════════════════════════════
function buildLighting() {
    const t = isDayMode ? THEMES.day : THEMES.night;
    const ambient = new THREE.AmbientLight(t.ambient, t.ambientI);
    scene.add(ambient);
    sceneRefs.ambient = ambient;

    const dir = new THREE.DirectionalLight(t.dirColor, t.dirI);
    dir.position.set(20, 30, 15);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    dir.shadow.camera.left = -40; dir.shadow.camera.right = 40;
    dir.shadow.camera.top = 40; dir.shadow.camera.bottom = -40;
    dir.shadow.camera.near = 1; dir.shadow.camera.far = 80;
    dir.shadow.bias = -0.001;
    scene.add(dir);
    sceneRefs.dir = dir;

    const fill = new THREE.DirectionalLight(t.fillColor, t.fillI);
    fill.position.set(-15, 20, -10);
    scene.add(fill);
    sceneRefs.fill = fill;

    const hemi = new THREE.HemisphereLight(t.hemiSky, t.hemiGnd, t.hemiI);
    scene.add(hemi);
    sceneRefs.hemi = hemi;

    // Zone point lights
    for (const z of ZONES) {
        const pl = new THREE.PointLight(z.color, isDayMode ? 0.3 : 0.8, 25, 1.5);
        pl.position.set(z.x, 5, z.z);
        scene.add(pl);
    }
}

// ═══════════════════════════════════════════════════════
// FLOOR
// ═══════════════════════════════════════════════════════
function buildFloor() {
    const t = isDayMode ? THEMES.day : THEMES.night;
    // Dynamic floor size based on layout
    const allX = ZONES.map(z => [z.x - z.w/2, z.x + z.w/2]).flat();
    const allZ = ZONES.map(z => [z.z - z.h/2, z.z + z.h/2]).flat();
    const fw = Math.max(80, (Math.max(...allX) - Math.min(...allX)) + 20);
    const fh = Math.max(60, (Math.max(...allZ) - Math.min(...allZ)) + 20);
    const floorGeo = new THREE.PlaneGeometry(fw, fh);
    const floorMat = new THREE.MeshStandardMaterial({ color: t.floor, roughness: 0.7, metalness: 0.15 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.01;
    floor.receiveShadow = true;
    scene.add(floor);
    sceneRefs.floor = floor;

    const gridHelper = new THREE.GridHelper(Math.max(fw, fh), 40, t.grid1, t.grid2);
    gridHelper.position.y = 0.01;
    scene.add(gridHelper);
    sceneRefs.grid = gridHelper;
}

// ═══════════════════════════════════════════════════════
// ZONES — floor areas for missions + shared
// ═══════════════════════════════════════════════════════
function buildZones() {
    for (const z of ZONES) {
        const geo = new THREE.PlaneGeometry(z.w, z.h);
        const mat = new THREE.MeshStandardMaterial({
            color: isDayMode ? (z.floorDay || 0xd0d0d0) : (z.floorColor || 0x1a1a2a),
            roughness: 0.9, metalness: 0.1, transparent: true, opacity: 0.8,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.set(z.x, 0.02, z.z);
        mesh.receiveShadow = true;
        scene.add(mesh);
        sceneRefs.zoneMeshes.push({ mesh, zone: z });

        const border = new THREE.EdgesGeometry(new THREE.PlaneGeometry(z.w, z.h));
        const borderMat = new THREE.LineBasicMaterial({ color: z.color, transparent: true, opacity: 0.6 });
        const borderLine = new THREE.LineSegments(border, borderMat);
        borderLine.rotation.x = -Math.PI / 2;
        borderLine.position.set(z.x, 0.03, z.z);
        scene.add(borderLine);
    }
}

// ═══════════════════════════════════════════════════════
// MISSION BUILDINGS — walls + conveyors + phase stations
// ═══════════════════════════════════════════════════════
let conveyorCubes = []; // animated cubes on belts

function buildMissionBuildings() {
    const wallMat = new THREE.MeshStandardMaterial({
        color: isDayMode ? 0xe8e0d0 : 0x2a2540, transparent: true, opacity: 0.3,
        roughness: 0.8, side: THREE.DoubleSide,
    });
    const beltMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.3, metalness: 0.6 });
    const PHASE_COLORS = { done: 0x22c55e, completed: 0x22c55e, running: 0x3b82f6, pending: 0x4b5563, failed: 0xef4444, done_with_issues: 0xeab308, paused: 0x6b7280 };
    const wallH = 3.5;

    for (const mz of MISSION_ZONES) {
        const m = mz.mission;
        const phases = m.phases || [];
        if (phases.length === 0) continue;
        const hw = mz.w / 2, hh = mz.h / 2;

        // ── Building walls (3 sides, front open) ──
        const back = new THREE.Mesh(new THREE.PlaneGeometry(mz.w, wallH), wallMat);
        back.position.set(mz.x, wallH / 2, mz.z - hh); scene.add(back);
        const left = new THREE.Mesh(new THREE.PlaneGeometry(mz.h, wallH), wallMat);
        left.rotation.y = Math.PI / 2; left.position.set(mz.x - hw, wallH / 2, mz.z); scene.add(left);
        const right = new THREE.Mesh(new THREE.PlaneGeometry(mz.h, wallH), wallMat);
        right.rotation.y = Math.PI / 2; right.position.set(mz.x + hw, wallH / 2, mz.z); scene.add(right);

        // ── Roof beam ──
        const roof = new THREE.Mesh(new THREE.BoxGeometry(mz.w, 0.1, mz.h),
            new THREE.MeshStandardMaterial({ color: isDayMode ? 0xd0c8b8 : 0x2a2040, transparent: true, opacity: 0.15 }));
        roof.position.set(mz.x, wallH, mz.z); scene.add(roof);

        // ── Sign ──
        const shortName = (m.name || '').length > 25 ? m.name.slice(0, 22) + '…' : m.name;
        const sign = makeTextSprite(shortName, mz.color, 0.35);
        sign.position.set(mz.x, wallH + 0.5, mz.z - hh);
        scene.add(sign);

        // ── Status badge ──
        const badge = makeTextSprite(`${m.phases_done}/${m.phases_total}`, 0xffffff, 0.2);
        badge.position.set(mz.x, wallH + 0.1, mz.z - hh);
        scene.add(badge);

        // ── Conveyor belt ──
        const startX = mz.x - hw + BLDG_PAD;
        const beltLen = phases.length * PHASE_W;
        const belt = new THREE.Mesh(new THREE.BoxGeometry(beltLen, 0.06, 0.5), beltMat);
        belt.position.set(startX + beltLen / 2 - PHASE_W / 2, 0.12, mz.z);
        belt.receiveShadow = true;
        scene.add(belt);

        // ── Belt rails ──
        for (const rz of [-0.35, 0.35]) {
            const rail = new THREE.Mesh(new THREE.BoxGeometry(beltLen + 0.5, 0.03, 0.04),
                new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7 }));
            rail.position.set(startX + beltLen / 2 - PHASE_W / 2, 0.15, mz.z + rz);
            scene.add(rail);
        }

        // ── Phase stations ──
        for (let pi = 0; pi < phases.length; pi++) {
            const phase = phases[pi];
            const px = startX + pi * PHASE_W;
            const pColor = PHASE_COLORS[phase.status] || PHASE_COLORS.pending;

            // Station box
            const station = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.5, 1.0),
                new THREE.MeshStandardMaterial({ color: pColor, roughness: 0.4, metalness: 0.2 }));
            station.position.set(px, 0.4, mz.z);
            station.castShadow = true;
            scene.add(station);

            // Phase label
            const phaseName = (phase.name || '').length > 12 ? phase.name.slice(0, 10) + '…' : phase.name;
            const lbl = makeTextSprite(phaseName, 0xffffff, 0.18);
            lbl.position.set(px, 1.1, mz.z);
            scene.add(lbl);

            // Running indicator — pulsing sphere
            if (phase.status === 'running') {
                const pulse = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x3b82f6, emissiveIntensity: 0.8, transparent: true }));
                pulse.position.set(px, 0.8, mz.z);
                pulse.userData.isPulse = true;
                scene.add(pulse);
            }

            // Done checkmark
            if (phase.status === 'done' || phase.status === 'completed') {
                const check = makeTextSprite('✓', 0x22c55e, 0.25);
                check.position.set(px, 0.85, mz.z);
                scene.add(check);
            }

            // Arrow to next phase
            if (pi < phases.length - 1) {
                const arrow = makeTextSprite('▶', isDayMode ? 0x888888 : 0x555555, 0.12);
                arrow.position.set(px + PHASE_W / 2, 0.4, mz.z);
                scene.add(arrow);
            }
        }

        // ── Moving cubes on belt (between done and running) ──
        const firstRunning = phases.findIndex(p => p.status === 'running');
        if (firstRunning > 0) {
            for (let ci = 0; ci < 2; ci++) {
                const cube = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2),
                    new THREE.MeshStandardMaterial({ color: mz.color, emissive: mz.color, emissiveIntensity: 0.5 }));
                const fromX = startX + (firstRunning - 1) * PHASE_W;
                const toX = startX + firstRunning * PHASE_W;
                cube.position.set(fromX, 0.25, mz.z + (ci === 0 ? 0.2 : -0.2));
                scene.add(cube);
                conveyorCubes.push({ mesh: cube, fromX, toX, speed: 0.3 + ci * 0.15, phase: 0 });
            }
        }

        // ── Desks alongside conveyor for agents ──
        const woodMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0x8B7355 : 0x5c4033, roughness: 0.7 });
        const screenMat = new THREE.MeshStandardMaterial({ color: 0x111118, roughness: 0.3, metalness: 0.5 });
        for (let pi = 0; pi < Math.min(phases.length, 6); pi++) {
            if (phases[pi].status === 'running' || phases[pi].status === 'done' || phases[pi].status === 'completed') {
                const px = startX + pi * PHASE_W;
                // Desk behind conveyor
                const desk = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.06, 0.7), woodMat);
                desk.position.set(px, 0.7, mz.z + 2);
                desk.castShadow = true;
                scene.add(desk);
                // Screen
                const scr = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.03), screenMat);
                scr.position.set(px, 1.15, mz.z + 1.8);
                scr.userData.isScreen = true;
                scene.add(scr);
            }
        }
    }

    // Update mission counter
    document.getElementById('world-mission-count').textContent = MISSION_ZONES.length + ' missions';
}

// ═══════════════════════════════════════════════════════
// SHARED ZONE FURNITURE — Board Room + Chill
// ═══════════════════════════════════════════════════════
function buildSharedFurniture() {
    const boardZone = ZONES.find(z => z.id === 'board');
    const chillZone = ZONES.find(z => z.id === 'chill');
    if (!boardZone || !chillZone) return;

    const woodMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0x8B7355 : 0x5c4033, roughness: 0.7 });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x2a2a35, roughness: 0.6 });
    const whiteMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.9 });
    const sofaMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 });

    const bx = boardZone.x, bz = boardZone.z;

    // Board Room — walls
    const wallMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0xe8e0d0 : 0x2a2540, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
    for (const [px, pz, pw, rot] of [[bx, bz-4, 12, 0], [bx-6, bz, 8, Math.PI/2], [bx+6, bz, 8, Math.PI/2]]) {
        const w = new THREE.Mesh(new THREE.PlaneGeometry(pw, 3.5), wallMat);
        w.rotation.y = rot; w.position.set(px, 1.75, pz); scene.add(w);
    }
    // Board sign
    const boardSign = makeTextSprite('Board Room', 0xd4a017, 0.35);
    boardSign.position.set(bx, 4, bz - 4); scene.add(boardSign);

    // Long table
    const table = new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, 2.5), woodMat);
    table.position.set(bx, 0.75, bz); table.castShadow = true; scene.add(table);
    // Chairs
    for (let i = 0; i < 3; i++) {
        for (const dz of [-2, 2]) {
            const chair = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), darkMat);
            chair.position.set(bx - 3 + i * 3, 0.4, bz + dz); scene.add(chair);
        }
    }
    // Big screen
    const bigScr = new THREE.Mesh(new THREE.BoxGeometry(5, 2.5, 0.1),
        new THREE.MeshStandardMaterial({ color: 0x111118, roughness: 0.3, metalness: 0.5 }));
    bigScr.position.set(bx, 2, bz - 3.9); scene.add(bigScr);

    // Chill Zone — walls only on 2 sides
    const cx = chillZone.x, cz = chillZone.z;
    const chillSign = makeTextSprite('Chill Zone', 0x84cc16, 0.35);
    chillSign.position.set(cx, 4, cz - 5); scene.add(chillSign);

    // Sofa
    const sofaBase = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 1.2), sofaMat);
    sofaBase.position.set(cx, 0.4, cz - 2); sofaBase.castShadow = true; scene.add(sofaBase);
    const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(4, 0.6, 0.2), sofaMat);
    sofaBack.position.set(cx, 0.8, cz - 2.5); scene.add(sofaBack);

    // Coffee table
    const coffeeT = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 0.8), woodMat);
    coffeeT.position.set(cx, 0.5, cz - 0.5); scene.add(coffeeT);

    // Whiteboard
    const wb = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 0.08), whiteMat);
    wb.position.set(cx + 3, 1.8, cz + 4); scene.add(wb);
}

// ═══════════════════════════════════════════════════════
// NATURE — trees, fountain, skybox
// ═══════════════════════════════════════════════════════
function buildNature() {
    // Trees around the perimeter (dynamic based on layout extents)
    const allX = ZONES.map(z => [z.x - z.w/2, z.x + z.w/2]).flat();
    const allZ = ZONES.map(z => [z.z - z.h/2, z.z + z.h/2]).flat();
    const minX = Math.min(-30, ...allX) - 5, maxX = Math.max(30, ...allX) + 5;
    const minZ = Math.min(-25, ...allZ) - 5, maxZ = Math.max(25, ...allZ) + 5;
    const treePositions = [];
    // Left and right edges
    for (let tz = minZ + 2; tz <= maxZ - 2; tz += 8) {
        treePositions.push([minX, tz], [maxX, tz]);
    }
    // Top and bottom edges
    for (let tx = minX + 6; tx <= maxX - 6; tx += 8) {
        treePositions.push([tx, minZ], [tx, maxZ]);
    }
    for (const [tx, tz] of treePositions) {
        const h = 2.5 + Math.random() * 2;
        const trunkMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0x8B5A2B : 0x4a3020, roughness: 0.9 });
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, h * 0.5, 6), trunkMat);
        trunk.position.set(tx, h * 0.25, tz);
        trunk.castShadow = true;
        scene.add(trunk);
        const leafMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0x4CAF50 : 0x1a5c30, roughness: 0.8 });
        const crown = new THREE.Mesh(new THREE.ConeGeometry(h * 0.4, h * 0.6, 6), leafMat);
        crown.position.set(tx, h * 0.7, tz);
        crown.castShadow = true;
        scene.add(crown);
        sceneRefs.trees.push({ trunk, crown });
    }

    // Fountain in chill zone (dynamic position)
    const chillZ = ZONES.find(z => z.id === 'chill');
    const fx = chillZ ? chillZ.x : 25, fz = chillZ ? chillZ.z + 2 : 4;
    const basinMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0xbbb8b0 : 0x3a3550, roughness: 0.4, metalness: 0.3 });
    const basin = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.8, 0.4, 16), basinMat);
    basin.position.set(fx, 0.2, fz);
    scene.add(basin);
    const waterMat = new THREE.MeshStandardMaterial({
        color: isDayMode ? 0x4488cc : 0x2244aa, transparent: true, opacity: 0.6,
        roughness: 0.1, metalness: 0.5,
    });
    const water = new THREE.Mesh(new THREE.CylinderGeometry(1.3, 1.3, 0.05, 16), waterMat);
    water.position.set(fx, 0.38, fz);
    scene.add(water);
    sceneRefs.fountain = water;
    // Fountain pillar
    const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 1.2, 8), basinMat);
    pillar.position.set(fx, 0.8, fz);
    scene.add(pillar);

    // Sky dome
    const skyGeo = new THREE.SphereGeometry(90, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
    const skyMat = new THREE.MeshBasicMaterial({
        color: isDayMode ? 0x87CEEB : 0x0a0820, side: THREE.BackSide,
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);
    sceneRefs.skyDome = sky;

    // Stars (night only)
    if (!isDayMode) buildStars();
}

function buildStars() {
    const count = 200;
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI * 0.4;
        const r = 85;
        pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
        pos[i*3+1] = r * Math.cos(phi);
        pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3, transparent: true, opacity: 0.7 });
    const stars = new THREE.Points(geo, mat);
    scene.add(stars);
    sceneRefs.stars = stars;
}

// ═══════════════════════════════════════════════════════
// AGENTS (Box-people)
// ═══════════════════════════════════════════════════════
function buildAgents() {
    const zoneDesks = {};
    for (const z of ZONES) zoneDesks[z.id] = { seats: [], idx: 0 };

    // Pre-compute seats per zone
    computeZoneSeats(zoneDesks);

    for (const ad of AGENT_DATA) {
        const zone = assignZone(ad);
        const seat = getNextSeat(zoneDesks, zone);
        const agentMesh = createAgentMesh(ad);
        agentMesh.position.set(seat.x, 0, seat.z);
        agentMesh.userData.agentId = ad.id;
        scene.add(agentMesh);

        agents[ad.id] = {
            mesh: agentMesh,
            data: ad,
            zone: zone,
            seat: seat,
            target: { x: seat.x, z: seat.z },
            status: 'idle',
            walkPhase: Math.random() * Math.PI * 2,
            speechBubble: null,
            thoughtBubble: null,
            walkSpeed: 1.5 + Math.random() * 0.5,
            idleTimer: Math.random() * 10,
        };
    }
}

function computeZoneSeats(zoneDesks) {
    // Mission zones: seats alongside conveyor at running/done phases
    for (const mz of MISSION_ZONES) {
        const phases = mz.mission.phases || [];
        const startX = mz.x - mz.w / 2 + BLDG_PAD;
        for (let pi = 0; pi < phases.length; pi++) {
            const px = startX + pi * PHASE_W;
            if (phases[pi].status === 'running' || phases[pi].status === 'done' || phases[pi].status === 'completed') {
                for (let si = 0; si < 3; si++) {
                    zoneDesks[mz.id].seats.push({
                        x: px + (si - 1) * 0.8,
                        z: mz.z + 2.5 + (si % 2) * 0.8,
                    });
                }
            }
        }
        // Fallback: center of zone
        if (zoneDesks[mz.id].seats.length === 0) {
            zoneDesks[mz.id].seats.push({ x: mz.x, z: mz.z + 2 });
        }
    }

    // Board Room: 6 chairs around table
    if (zoneDesks.board) {
        const bz = ZONES.find(z => z.id === 'board');
        if (bz) {
            for (let i = 0; i < 3; i++) {
                zoneDesks.board.seats.push({ x: bz.x - 3 + i * 3, z: bz.z - 2 });
                zoneDesks.board.seats.push({ x: bz.x - 3 + i * 3, z: bz.z + 2 });
            }
        }
    }

    // Chill Zone: scattered seats
    if (zoneDesks.chill) {
        const cz = ZONES.find(z => z.id === 'chill');
        if (cz) {
            zoneDesks.chill.seats.push(
                { x: cz.x - 1, z: cz.z - 1 }, { x: cz.x + 1, z: cz.z - 1 },
                { x: cz.x, z: cz.z + 1 }, { x: cz.x + 2, z: cz.z + 2 },
                { x: cz.x - 2, z: cz.z + 2 }, { x: cz.x, z: cz.z + 3 },
                { x: cz.x + 3, z: cz.z }, { x: cz.x - 3, z: cz.z },
            );
        }
    }
}

function assignZone(agent) {
    // Priority: match agent to mission via session
    const agentSession = LIVE_DATA.agent_sessions ? LIVE_DATA.agent_sessions[agent.id] : null;
    if (agentSession) {
        for (const mz of MISSION_ZONES) {
            if (mz.mission.session_id === agentSession) return mz.id;
        }
    }
    // Board Room for leadership
    const boardZone = ZONES.find(z => z.id === 'board');
    if (boardZone && boardZone.roles && boardZone.roles.includes(agent.role)) return 'board';
    const rank = agent.hierarchy_rank || 50;
    if (rank <= 10) return 'board';
    // Chill fallback
    return 'chill';
}

function getNextSeat(zoneDesks, zoneId) {
    const z = zoneDesks[zoneId];
    if (!z || z.seats.length === 0) {
        const cz = ZONES.find(zn => zn.id === 'chill');
        return { x: (cz ? cz.x : 25) + (Math.random() - 0.5) * 6, z: (cz ? cz.z : 0) + (Math.random() - 0.5) * 6 };
    }
    const seat = z.seats[z.idx % z.seats.length];
    z.idx++;
    return { x: seat.x + (z.idx > z.seats.length ? (Math.random() - 0.5) * 1.5 : 0), z: seat.z };
}

function createAgentMesh(agent) {
    const group = new THREE.Group();
    const bodyColor = new THREE.Color(agent.color || '#7c3aed');
    const skinColor = new THREE.Color(0xe8beac);

    // Body
    const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.6 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.6, 0.25), bodyMat);
    body.position.y = 0.95;
    body.castShadow = true;
    group.add(body);

    // Head
    const headMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.7 });
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.3), headMat);
    head.position.y = 1.5;
    head.castShadow = true;
    group.add(head);

    // Arms
    const armMat = new THREE.MeshStandardMaterial({ color: bodyColor.clone().multiplyScalar(0.85), roughness: 0.6 });
    const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.45, 0.12), armMat);
    leftArm.position.set(-0.32, 0.95, 0);
    leftArm.userData.isArm = true;
    group.add(leftArm);
    const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.45, 0.12), armMat);
    rightArm.position.set(0.32, 0.95, 0);
    rightArm.userData.isArm = true;
    group.add(rightArm);

    // Legs
    const legMat = new THREE.MeshStandardMaterial({ color: 0x2a2a3a, roughness: 0.7 });
    const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.5, 0.14), legMat);
    leftLeg.position.set(-0.12, 0.38, 0);
    leftLeg.userData.isLeg = true;
    group.add(leftLeg);
    const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.5, 0.14), legMat);
    rightLeg.position.set(0.12, 0.38, 0);
    rightLeg.userData.isLeg = true;
    group.add(rightLeg);

    // Plumbob (diamond)
    const plumbobGeo = new THREE.OctahedronGeometry(0.15, 0);
    const plumbobMat = new THREE.MeshStandardMaterial({
        color: STATUS_COLORS.idle,
        emissive: STATUS_COLORS.idle,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.85,
    });
    const plumbob = new THREE.Mesh(plumbobGeo, plumbobMat);
    plumbob.position.y = 2.1;
    plumbob.userData.isPlumbob = true;
    group.add(plumbob);

    // Name tag (billboard sprite)
    const nameSprite = makeTextSprite(agent.name, 0xffffff, 0.22);
    nameSprite.position.y = 1.85;
    group.add(nameSprite);

    return group;
}

// ═══════════════════════════════════════════════════════
// TEXT SPRITES (canvas → texture → sprite)
// ═══════════════════════════════════════════════════════
function makeTextSprite(text, color, scale = 0.3) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 48;
    ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
    const metrics = ctx.measureText(text);
    const w = Math.ceil(metrics.width) + 20;
    const h = fontSize + 16;
    canvas.width = w;
    canvas.height = h;

    ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
    const c = new THREE.Color(color);
    ctx.fillStyle = `rgba(${c.r*255|0},${c.g*255|0},${c.b*255|0},0.9)`;
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 10, h / 2);

    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(scale * w / h * 2, scale * 2, 1);
    return sprite;
}

function makeSpeechBubble(text, maxWidth = 200) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 28;
    const padding = 16;
    canvas.width = maxWidth + padding * 2;
    canvas.height = 80;

    ctx.font = `${fontSize}px system-ui, sans-serif`;
    // Truncate text
    let displayText = text;
    if (ctx.measureText(text).width > maxWidth) {
        while (ctx.measureText(displayText + '…').width > maxWidth && displayText.length > 0)
            displayText = displayText.slice(0, -1);
        displayText += '…';
    }

    // Background
    const tw = ctx.measureText(displayText).width + padding * 2;
    canvas.width = tw;
    ctx.font = `${fontSize}px system-ui, sans-serif`;
    ctx.fillStyle = 'rgba(124,58,237,0.92)';
    roundRect(ctx, 0, 0, tw, 52, 10);
    ctx.fill();
    // Triangle
    ctx.beginPath();
    ctx.moveTo(tw / 2 - 6, 52);
    ctx.lineTo(tw / 2, 64);
    ctx.lineTo(tw / 2 + 6, 52);
    ctx.fill();
    // Text
    ctx.fillStyle = '#fff';
    ctx.textBaseline = 'middle';
    ctx.fillText(displayText, padding / 2, 26);

    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(tw / 60, 64 / 60, 1);
    return sprite;
}

function makeThoughtBubble() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(234,179,8,0.85)';
    ctx.beginPath();
    ctx.arc(32, 24, 22, 0, Math.PI * 2);
    ctx.fill();
    // Dots
    ctx.fillStyle = '#1a1025';
    for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(20 + i * 12, 24, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    // Small bubbles
    ctx.fillStyle = 'rgba(234,179,8,0.6)';
    ctx.beginPath(); ctx.arc(28, 50, 5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(24, 58, 3, 0, Math.PI * 2); ctx.fill();

    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(0.8, 0.8, 1);
    return sprite;
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

// ═══════════════════════════════════════════════════════
// AMBIENT PARTICLES
// ═══════════════════════════════════════════════════════
function buildAmbientParticles() {
    const count = 60;
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 70;
        positions[i * 3 + 1] = 0.5 + Math.random() * 5;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
        const c = new THREE.Color(0x7c3aed).lerp(new THREE.Color(0x3b82f6), Math.random());
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({
        size: 0.08,
        vertexColors: true,
        transparent: true,
        opacity: 0.5,
        depthWrite: false,
    });
    const particles = new THREE.Points(geo, mat);
    particles.userData.isAmbient = true;
    scene.add(particles);
    particleSystems.push(particles);
}

// ═══════════════════════════════════════════════════════
// ANIMATION LOOP
// ═══════════════════════════════════════════════════════
function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.05);
    const elapsed = clock.getElapsedTime();

    controls.update();

    // Animate agents
    for (const id in agents) {
        const ag = agents[id];
        animateAgent(ag, dt, elapsed);
    }

    // Blink server LEDs
    scene.traverse(obj => {
        if (obj.userData.isLED) {
            const v = Math.sin(elapsed * obj.userData.blinkSpeed + obj.userData.blinkOffset);
            obj.material.opacity = 0.3 + v * 0.7;
            obj.visible = v > -0.3;
        }
        // Pulse running phase indicators
        if (obj.userData.isPulse) {
            const s = 0.8 + Math.sin(elapsed * 3) * 0.3;
            obj.scale.setScalar(s);
            obj.material.emissiveIntensity = 0.5 + Math.sin(elapsed * 4) * 0.4;
        }
    });

    // Conveyor cubes — ping-pong animation
    for (const cc of conveyorCubes) {
        cc.phase += dt * cc.speed;
        const t = (Math.sin(cc.phase) + 1) / 2;
        cc.mesh.position.x = cc.fromX + (cc.toX - cc.fromX) * t;
        cc.mesh.rotation.y = elapsed * 2;
    }

    // Ambient particles float
    for (const ps of particleSystems) {
        const pos = ps.geometry.attributes.position;
        for (let i = 0; i < pos.count; i++) {
            pos.array[i * 3 + 1] += Math.sin(elapsed * 0.3 + i) * 0.003;
            pos.array[i * 3] += Math.cos(elapsed * 0.2 + i * 0.5) * 0.002;
        }
        pos.needsUpdate = true;
    }

    // Fountain water wobble
    if (sceneRefs.fountain) {
        sceneRefs.fountain.position.y = 0.38 + Math.sin(elapsed * 2) * 0.02;
        sceneRefs.fountain.rotation.y = elapsed * 0.3;
    }

    renderer.render(scene, camera);
}

function animateAgent(ag, dt, elapsed) {
    const mesh = ag.mesh;
    const plumbob = mesh.children.find(c => c.userData.isPlumbob);
    const arms = mesh.children.filter(c => c.userData.isArm);
    const legs = mesh.children.filter(c => c.userData.isLeg);

    // Plumbob — always bob and rotate
    if (plumbob) {
        plumbob.rotation.y += dt * (ag.status === 'thinking' ? 3 : 0.5);
        plumbob.position.y = 2.1 + Math.sin(elapsed * 1.5 + ag.walkPhase) * 0.08;
    }

    // Movement toward target
    const dx = ag.target.x - mesh.position.x;
    const dz = ag.target.z - mesh.position.z;
    const dist = Math.sqrt(dx * dx + dz * dz);

    if (dist > 0.15) {
        // Walking
        const speed = ag.walkSpeed * dt;
        const step = Math.min(speed, dist);
        mesh.position.x += (dx / dist) * step;
        mesh.position.z += (dz / dist) * step;

        // Face direction
        mesh.rotation.y = Math.atan2(dx, dz);

        // Walk cycle
        ag.walkPhase += dt * 8;
        const legSwing = Math.sin(ag.walkPhase) * 0.4;
        if (legs[0]) legs[0].rotation.x = legSwing;
        if (legs[1]) legs[1].rotation.x = -legSwing;
        if (arms[0]) arms[0].rotation.x = -legSwing * 0.6;
        if (arms[1]) arms[1].rotation.x = legSwing * 0.6;
    } else {
        // At destination — status-based animation
        // Reset legs
        for (const l of legs) l.rotation.x *= 0.9;

        if (ag.status === 'acting') {
            // Typing — arms oscillate fast
            const typingPhase = elapsed * 6 + ag.walkPhase;
            if (arms[0]) arms[0].rotation.x = Math.sin(typingPhase) * 0.25;
            if (arms[1]) arms[1].rotation.x = Math.sin(typingPhase + 1) * 0.25;
        } else if (ag.status === 'thinking') {
            // Subtle sway
            if (arms[0]) arms[0].rotation.x = Math.sin(elapsed * 0.8) * 0.1;
        } else {
            // Idle — arms rest
            for (const a of arms) a.rotation.x *= 0.95;
        }

        // Idle behavior — occasional head turn
        ag.idleTimer -= dt;
        if (ag.idleTimer <= 0 && ag.status === 'idle') {
            ag.idleTimer = 5 + Math.random() * 10;
            // Small random rotation
            mesh.rotation.y += (Math.random() - 0.5) * 0.5;
        }
    }

    // Speech bubble fade
    if (ag.speechBubble) {
        ag.speechBubble._life -= dt;
        if (ag.speechBubble._life <= 0) {
            mesh.remove(ag.speechBubble);
            ag.speechBubble = null;
        } else if (ag.speechBubble._life < 0.5) {
            ag.speechBubble.material.opacity = ag.speechBubble._life * 2;
        }
    }

    // Thought bubble for thinking status
    if (ag.status === 'thinking' && !ag.thoughtBubble) {
        ag.thoughtBubble = makeThoughtBubble();
        ag.thoughtBubble.position.set(0.4, 2.2, 0);
        mesh.add(ag.thoughtBubble);
    } else if (ag.status !== 'thinking' && ag.thoughtBubble) {
        mesh.remove(ag.thoughtBubble);
        ag.thoughtBubble = null;
    }
    if (ag.thoughtBubble) {
        ag.thoughtBubble.position.y = 2.2 + Math.sin(elapsed * 2) * 0.1;
    }
}

// ═══════════════════════════════════════════════════════
// STATUS UPDATE
// ═══════════════════════════════════════════════════════
function updateAgentStatus(agentId, newStatus, task) {
    const ag = agents[agentId];
    if (!ag) return;

    const oldStatus = ag.status;
    ag.status = newStatus;

    // Update plumbob color
    const plumbob = ag.mesh.children.find(c => c.userData.isPlumbob);
    if (plumbob) {
        const color = STATUS_COLORS[newStatus] || STATUS_COLORS.idle;
        plumbob.material.color.setHex(color);
        plumbob.material.emissive.setHex(color);
        plumbob.material.emissiveIntensity = newStatus === 'acting' ? 0.8 : 0.6;
    }

    // Glow nearby screens when acting
    if (newStatus === 'acting') {
        glowNearbyScreen(ag.mesh.position, true);
    } else if (oldStatus === 'acting') {
        glowNearbyScreen(ag.mesh.position, false);
    }

    // Feed item
    addFeedItem(ag.data.name, newStatus, task);

    // Update counters
    updateCounters();
}

function glowNearbyScreen(pos, on) {
    scene.traverse(obj => {
        if (obj.userData.isScreen) {
            const d = obj.getWorldPosition(new THREE.Vector3()).distanceTo(pos);
            if (d < 3) {
                if (on) {
                    obj.material = new THREE.MeshStandardMaterial({
                        color: 0x1a1a2a,
                        emissive: 0x3b82f6,
                        emissiveIntensity: 0.5,
                        roughness: 0.3,
                    });
                } else {
                    obj.material = new THREE.MeshStandardMaterial({
                        color: 0x111118, roughness: 0.3, metalness: 0.5
                    });
                }
            }
        }
    });
}

function showSpeechBubble(agentId, text) {
    const ag = agents[agentId];
    if (!ag) return;

    // Remove old bubble
    if (ag.speechBubble) {
        ag.mesh.remove(ag.speechBubble);
    }

    const bubble = makeSpeechBubble(text);
    bubble.position.set(0, 2.5, 0);
    bubble._life = 5; // seconds
    ag.mesh.add(bubble);
    ag.speechBubble = bubble;
}

function triggerDelegation(fromId, toId) {
    const from = agents[fromId];
    const to = agents[toId];
    if (!from || !to) return;

    // Walk from agent to target agent
    from.target = {
        x: to.mesh.position.x + (Math.random() - 0.5) * 1.5,
        z: to.mesh.position.z + (Math.random() - 0.5) * 1.5
    };

    // After a delay, walk back
    setTimeout(() => {
        from.target = { x: from.seat.x, z: from.seat.z };
    }, 4000);
}

// ═══════════════════════════════════════════════════════
// UI: FEED, ZONES, COUNTERS
// ═══════════════════════════════════════════════════════
const feedEl = document.getElementById('world-feed');

function addFeedItem(name, status, detail) {
    const time = new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
    const item = document.createElement('div');
    item.className = 'wf-item';
    item.innerHTML = `<span class="wf-dot wf-dot--${status}"></span>
        <div><span class="wf-time">${time}</span> <span class="wf-name">${name}</span>
        <span>${statusLabel(status)}${detail ? ' — ' + truncate(detail, 40) : ''}</span></div>`;
    feedEl.prepend(item);
    // Keep max 30
    while (feedEl.children.length > 30) feedEl.lastChild.remove();
}

function statusLabel(s) {
    const labels = { idle: 'repos', thinking: 'réfléchit', acting: 'code', waiting: 'attend', blocked: 'bloqué', error: 'erreur', stopped: 'arrêté' };
    return labels[s] || s;
}

function truncate(s, n) { return s && s.length > n ? s.slice(0, n) + '…' : s || ''; }

function updateCounters() {
    const total = Object.keys(agents).length;
    const active = Object.values(agents).filter(a => ['thinking', 'acting'].includes(a.status)).length;
    document.getElementById('world-agent-count').textContent = total + ' agents';
    document.getElementById('world-active-count').textContent = active + ' actifs';
}

function buildZoneLabelsUI() {
    const container = document.getElementById('world-zones');
    // Mission zones first
    for (const z of MISSION_ZONES) {
        const el = document.createElement('div');
        el.className = 'wz-label';
        el.style.borderLeftColor = '#' + z.color.toString(16).padStart(6, '0');
        const m = z.mission;
        el.textContent = `${(z.name || '').slice(0, 20)} (${m.phases_done}/${m.phases_total})`;
        el.onclick = () => flyToZone(z);
        container.appendChild(el);
    }
    // Shared zones
    for (const z of ZONES.filter(z => z.id === 'board' || z.id === 'chill')) {
        const el = document.createElement('div');
        el.className = 'wz-label';
        el.style.borderLeftColor = '#' + z.color.toString(16).padStart(6, '0');
        el.textContent = z.id === 'board' ? 'Board Room' : 'Chill Zone';
        el.onclick = () => flyToZone(z);
        container.appendChild(el);
    }
}

// ═══════════════════════════════════════════════════════
// INTERACTION (click, hover, keyboard)
// ═══════════════════════════════════════════════════════
function setupInteraction() {
    const canvas = renderer.domElement;

    canvas.addEventListener('click', (e) => {
        mouse.x = (e.offsetX / canvas.clientWidth) * 2 - 1;
        mouse.y = -(e.offsetY / canvas.clientHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // Find clicked agent
        const agentMeshes = Object.values(agents).map(a => a.mesh);
        const intersects = raycaster.intersectObjects(agentMeshes, true);
        if (intersects.length > 0) {
            let obj = intersects[0].object;
            while (obj.parent && !obj.userData.agentId) obj = obj.parent;
            if (obj.userData.agentId) {
                selectAgent(obj.userData.agentId);
                return;
            }
        }
        deselectAgent();
    });

    // Keyboard
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (e.key === 'Escape') deselectAgent();
        if (e.key === ' ') { e.preventDefault(); resetCamera(); }
        const idx = parseInt(e.key) - 1;
        if (idx >= 0 && idx < ZONES.length) flyToZone(ZONES[idx]);
    });
}

function selectAgent(agentId) {
    const ag = agents[agentId];
    if (!ag) return;
    selectedAgent = agentId;

    // Camera zoom to agent
    const targetPos = ag.mesh.position.clone();
    smoothCameraTo(targetPos.x + 4, 5, targetPos.z + 4, targetPos.x, 1, targetPos.z);

    // Show info panel
    const panel = document.getElementById('world-info');
    panel.style.display = 'block';
    document.getElementById('wi-avatar').textContent = ag.data.avatar || ag.data.name[0];
    document.getElementById('wi-avatar').style.background = ag.data.color;
    document.getElementById('wi-name').textContent = ag.data.name;
    document.getElementById('wi-role').textContent = ag.data.role;
    const statusEl = document.getElementById('wi-status');
    statusEl.querySelector('.dot').style.background = '#' + (STATUS_COLORS[ag.status] || 0x6b7280).toString(16).padStart(6, '0');
    statusEl.querySelector('span:last-child').textContent = statusLabel(ag.status);

    const taskEl = document.getElementById('wi-task');
    const missionText = ag.missionName ? `${ag.missionName}` : (ag.data.tagline || '');
    taskEl.style.display = missionText ? 'block' : 'none';
    taskEl.textContent = missionText;

    const skillsEl = document.getElementById('wi-skills');
    skillsEl.innerHTML = '';
    for (const s of (ag.data.skills || []).slice(0, 8)) {
        const tag = document.createElement('span');
        tag.className = 'wi-skill';
        tag.textContent = s;
        skillsEl.appendChild(tag);
    }
}

function deselectAgent() {
    selectedAgent = null;
    document.getElementById('world-info').style.display = 'none';
}

function flyToZone(zone) {
    smoothCameraTo(zone.x + 12, 18, zone.z + 12, zone.x, 0, zone.z);
}

function resetCamera() {
    smoothCameraTo(40, 35, 40, 5, 0, -5);
}

let cameraAnim = null;
function smoothCameraTo(cx, cy, cz, tx, ty, tz) {
    const start = {
        cx: camera.position.x, cy: camera.position.y, cz: camera.position.z,
        tx: controls.target.x, ty: controls.target.y, tz: controls.target.z,
    };
    const end = { cx, cy, cz, tx, ty, tz };
    const duration = 800;
    const startTime = performance.now();

    if (cameraAnim) cancelAnimationFrame(cameraAnim);

    function step() {
        const t = Math.min((performance.now() - startTime) / duration, 1);
        const ease = t < 0.5 ? 2 * t * t : 1 - (-2 * t + 2) ** 2 / 2; // easeInOutQuad
        camera.position.set(
            start.cx + (end.cx - start.cx) * ease,
            start.cy + (end.cy - start.cy) * ease,
            start.cz + (end.cz - start.cz) * ease,
        );
        controls.target.set(
            start.tx + (end.tx - start.tx) * ease,
            start.ty + (end.ty - start.ty) * ease,
            start.tz + (end.tz - start.tz) * ease,
        );
        if (t < 1) cameraAnim = requestAnimationFrame(step);
    }
    step();
}

// ═══════════════════════════════════════════════════════
// SSE — Real-time agent status
// ═══════════════════════════════════════════════════════
function connectSSE() {
    const evtSource = new EventSource('/sse/agents/status');

    evtSource.onmessage = (e) => {
        try {
            const data = JSON.parse(e.data);
            if (data.type === 'agent_status') {
                const agentId = data.agent_id;
                const status = (data.status || 'idle').toLowerCase();
                updateAgentStatus(agentId, status, data.current_task);
            }
            if (data.type === 'message' || data.type === 'stream_end') {
                const fromAgent = data.from_agent || data.agent_id;
                const content = data.content || '';
                if (fromAgent && content) {
                    showSpeechBubble(fromAgent, content);
                    const agName = agents[fromAgent]?.data?.name || fromAgent;
                    addFeedItem(agName, 'acting', content.slice(0, 120));
                }
                // Real interaction — walk to target
                if (data.to_agent && agents[fromAgent] && agents[data.to_agent]) {
                    triggerDelegation(fromAgent, data.to_agent);
                }
            }
            if (data.type === 'delegation') {
                triggerDelegation(data.from, data.to);
            }
        } catch (err) { /* ignore parse errors */ }
    };

    evtSource.onerror = () => {
        evtSource.close();
        setTimeout(() => connectSSE(), 5000);
    };

    // Also connect to monitoring SSE for live mission counts
    const monSSE = new EventSource('/sse/monitoring');
    monSSE.onmessage = (e) => {
        try {
            const data = JSON.parse(e.data);
            if (data.type === 'metrics' && data.agents_active !== undefined) {
                document.getElementById('world-active-count').textContent = data.agents_active + ' actifs';
            }
        } catch(err) {}
    };
    monSSE.onerror = () => { monSSE.close(); setTimeout(() => {}, 10000); };
}

// ═══════════════════════════════════════════════════════
// LIVE DATA — seed from server + SSE for real-time
// ═══════════════════════════════════════════════════════
function seedLiveData() {
    const messages = LIVE_DATA.messages || [];
    const agentSessions = LIVE_DATA.agent_sessions || {};
    const missions = LIVE_DATA.missions || [];

    // Mark agents with their active session/mission
    for (const [agentId, sessionId] of Object.entries(agentSessions)) {
        if (agents[agentId]) {
            agents[agentId].sessionId = sessionId;
            // Find mission for this session
            const mission = missions.find(m => m.session_id === sessionId);
            if (mission) agents[agentId].missionName = mission.brief || mission.name;
        }
    }

    // Show last N real messages in feed
    const recentMsgs = messages.slice(0, 15);
    for (const msg of recentMsgs.reverse()) {
        const agName = agents[msg.from]?.data?.name || msg.from;
        addFeedItem(agName, 'acting', msg.content);
    }

    // Show real speech bubbles for most recent messages
    for (const msg of messages.slice(0, 5)) {
        if (agents[msg.from]) {
            showSpeechBubble(msg.from, msg.content);
        }
        // If there's a target agent, trigger walk
        if (msg.to && agents[msg.from] && agents[msg.to]) {
            triggerDelegation(msg.from, msg.to);
        }
    }

    // Cluster agents by session — agents in same session cluster at their mission building
    const sessionGroups = {};
    for (const [aid, sid] of Object.entries(agentSessions)) {
        if (!sessionGroups[sid]) sessionGroups[sid] = [];
        sessionGroups[sid].push(aid);
    }
    for (const [sid, agentIds] of Object.entries(sessionGroups)) {
        if (agentIds.length < 2) continue;
        // Find the mission zone for this session
        const mz = MISSION_ZONES.find(z => z.mission.session_id === sid);
        if (!mz) continue;
        // Cluster around the active phase station
        const phases = mz.mission.phases || [];
        const runIdx = phases.findIndex(p => p.status === 'running');
        const phaseIdx = runIdx >= 0 ? runIdx : Math.max(0, phases.length - 1);
        const startX = mz.x - mz.w / 2 + BLDG_PAD;
        const cx = startX + phaseIdx * PHASE_W;
        const cz = mz.z + 2.5;
        for (let i = 0; i < agentIds.length; i++) {
            const ag = agents[agentIds[i]];
            if (!ag) continue;
            const angle = (i / agentIds.length) * Math.PI * 2;
            ag.target = { x: cx + Math.cos(angle) * 1.5, z: cz + Math.sin(angle) * 1.2 };
        }
    }

    updateCounters();

    // Periodic re-fetch of messages (poll every 30s for new activity)
    setInterval(async () => {
        try {
            const resp = await fetch('/api/sessions');
            if (!resp.ok) return;
        } catch(e) { /* ignore */ }
    }, 30000);
}

// ═══════════════════════════════════════════════════════
// DAY/NIGHT TOGGLE
// ═══════════════════════════════════════════════════════
function toggleDayNight() {
    isDayMode = !isDayMode;
    // Sync with site theme
    const theme = isDayMode ? 'light' : 'dark';
    localStorage.setItem('macaron_theme', theme);
    document.documentElement.setAttribute('data-theme', theme);
    document.getElementById('btn-daynight').innerHTML = isDayMode ? '<svg class="icon icon-sm"><use href="#icon-sun"/></svg>' : '<svg class="icon icon-sm"><use href="#icon-moon"/></svg>';
    applyDayNight(isDayMode, true);
}

function applyDayNight(day, animate) {
    const t = day ? THEMES.day : THEMES.night;

    // Scene background + fog
    scene.background = new THREE.Color(t.bg);
    scene.fog = new THREE.FogExp2(t.fog, 0.004);

    // Lights
    if (sceneRefs.ambient) { sceneRefs.ambient.color.setHex(t.ambient); sceneRefs.ambient.intensity = t.ambientI; }
    if (sceneRefs.dir) { sceneRefs.dir.color.setHex(t.dirColor); sceneRefs.dir.intensity = t.dirI; }
    if (sceneRefs.fill) { sceneRefs.fill.color.setHex(t.fillColor); sceneRefs.fill.intensity = t.fillI; }
    if (sceneRefs.hemi) { sceneRefs.hemi.color.setHex(t.hemiSky); sceneRefs.hemi.groundColor.setHex(t.hemiGnd); sceneRefs.hemi.intensity = t.hemiI; }

    // Floor
    if (sceneRefs.floor) sceneRefs.floor.material.color.setHex(t.floor);

    // Zone floors
    for (const { mesh, zone } of sceneRefs.zoneMeshes) {
        mesh.material.color.setHex(day ? zone.floorDay : zone.floorColor);
    }

    // Sky dome
    if (sceneRefs.skyDome) sceneRefs.skyDome.material.color.setHex(day ? 0x87CEEB : 0x0a0820);

    // Stars
    if (sceneRefs.stars) sceneRefs.stars.visible = !day;
    if (!day && !sceneRefs.stars) buildStars();

    // Trees — greener in day
    for (const tr of sceneRefs.trees) {
        tr.trunk.material.color.setHex(day ? 0x8B5A2B : 0x4a3020);
        tr.crown.material.color.setHex(day ? 0x4CAF50 : 0x1a5c30);
    }

    // Exposure
    renderer.toneMappingExposure = t.exposure;
}

// ═══════════════════════════════════════════════════════
// RESIZE
// ═══════════════════════════════════════════════════════
function onResize() {
    const canvas = renderer.domElement;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
}

// ═══════════════════════════════════════════════════════
// BOOTSTRAP
// ═══════════════════════════════════════════════════════
init();

</script>
{% endblock %}
