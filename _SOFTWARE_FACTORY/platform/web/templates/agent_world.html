{% extends "base.html" %}

{% block topbar_actions %}
<div style="display:flex;align-items:center;gap:10px;">
    <span class="badge badge-purple" id="world-agent-count">{{ agents|length }} agents</span>
    <span class="badge badge-green" id="world-active-count">0 actifs</span>
    <span class="badge badge-blue" id="world-mission-count">0 missions</span>
    <button class="btn btn-sm" onclick="worldToggleDayNight()" title="Jour/Nuit" id="btn-daynight">ğŸŒ™</button>
    <button class="btn btn-sm" onclick="worldResetCamera()" title="Reset camera">
        <svg class="icon icon-sm"><use href="#icon-maximize"/></svg>
    </button>
</div>
{% endblock %}

{% block content %}
<style>
/* â”€â”€ World Layout â”€â”€ */
.world-wrap{position:relative;width:100%;height:calc(100vh - 56px);overflow:hidden;background:#151020}
#world-canvas{width:100%;height:100%;display:block}

/* â”€â”€ HUD Overlay â”€â”€ */
.world-hud{position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none;z-index:10}
.world-hud > *{pointer-events:auto}

/* â”€â”€ Activity Feed â”€â”€ */
.world-feed{position:absolute;right:12px;top:12px;width:280px;max-height:45vh;overflow-y:auto;display:flex;flex-direction:column;gap:4px;scrollbar-width:thin;scrollbar-color:var(--purple-light) transparent}
.world-feed::-webkit-scrollbar{width:4px}
.world-feed::-webkit-scrollbar-thumb{background:var(--purple-light);border-radius:4px}
.wf-item{background:rgba(15,13,26,0.85);backdrop-filter:blur(8px);border:1px solid rgba(124,58,237,0.2);border-radius:8px;padding:6px 10px;font-size:0.72rem;color:var(--text-secondary);display:flex;align-items:flex-start;gap:6px;animation:wf-in .3s ease}
@keyframes wf-in{from{opacity:0;transform:translateX(20px)}to{opacity:1;transform:translateX(0)}}
.wf-dot{width:6px;height:6px;border-radius:50%;margin-top:4px;flex-shrink:0}
.wf-dot--thinking{background:var(--yellow)}
.wf-dot--acting{background:var(--blue)}
.wf-dot--idle{background:var(--green)}
.wf-dot--error{background:var(--red)}
.wf-time{color:var(--text-muted);font-size:0.65rem;white-space:nowrap}
.wf-name{color:var(--purple-light);font-weight:600}

/* â”€â”€ Agent Info Panel â”€â”€ */
.world-info{position:absolute;left:12px;bottom:12px;width:320px;background:rgba(15,13,26,0.92);backdrop-filter:blur(12px);border:1px solid rgba(124,58,237,0.3);border-radius:12px;padding:16px;display:none;animation:wi-in .25s ease}
@keyframes wi-in{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.wi-header{display:flex;align-items:center;gap:10px;margin-bottom:10px}
.wi-avatar{width:40px;height:40px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:1.3rem;font-weight:700;color:#fff}
.wi-name{font-size:0.95rem;font-weight:700;color:var(--text-primary)}
.wi-role{font-size:0.72rem;color:var(--text-secondary)}
.wi-status{display:inline-flex;align-items:center;gap:4px;font-size:0.7rem;padding:2px 8px;border-radius:8px;background:var(--bg-tertiary)}
.wi-status .dot{width:6px;height:6px;border-radius:50%}
.wi-task{font-size:0.75rem;color:var(--text-secondary);margin-top:8px;padding:8px;background:var(--bg-tertiary);border-radius:8px;max-height:60px;overflow:hidden}
.wi-skills{display:flex;flex-wrap:wrap;gap:3px;margin-top:8px}
.wi-skill{font-size:0.62rem;padding:1px 6px;border-radius:4px;background:rgba(124,58,237,0.2);color:var(--purple-light)}
.wi-close{position:absolute;top:8px;right:8px;background:none;border:none;color:var(--text-secondary);cursor:pointer;font-size:1rem}

/* â”€â”€ Zone Labels â”€â”€ */
.world-zones{position:absolute;left:12px;top:12px;display:flex;flex-direction:column;gap:3px}
.wz-label{font-size:0.65rem;color:var(--text-muted);padding:2px 8px;border-radius:4px;background:rgba(15,13,26,0.7);border-left:3px solid;cursor:pointer;transition:all .15s}
.wz-label:hover{color:var(--text-primary);background:rgba(15,13,26,0.9)}

/* â”€â”€ Loading â”€â”€ */
.world-loading{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#151020;z-index:100;transition:opacity .5s}
.world-loading.hidden{opacity:0;pointer-events:none}
.world-loading h3{color:var(--purple-light);font-size:1.2rem;margin-bottom:8px}
.world-loading p{color:var(--text-secondary);font-size:0.8rem}
.wl-bar{width:200px;height:3px;background:var(--bg-tertiary);border-radius:3px;overflow:hidden;margin-top:12px}
.wl-fill{height:100%;background:var(--purple);border-radius:3px;width:0%;transition:width .3s}

/* â”€â”€ Legend â”€â”€ */
.world-legend{position:absolute;right:12px;bottom:12px;display:flex;gap:10px;background:rgba(15,13,26,0.85);padding:6px 12px;border-radius:8px;border:1px solid rgba(124,58,237,0.15)}
.wl-item{display:flex;align-items:center;gap:4px;font-size:0.62rem;color:var(--text-secondary)}
.wl-diamond{width:8px;height:8px;transform:rotate(45deg);border-radius:1px}
</style>

<div class="world-wrap">
    <!-- Loading screen -->
    <div class="world-loading" id="world-loading">
        <h3>Macaron World</h3>
        <p>Construction du bureau...</p>
        <div class="wl-bar"><div class="wl-fill" id="world-load-bar"></div></div>
    </div>

    <!-- Three.js Canvas -->
    <canvas id="world-canvas"></canvas>

    <!-- HUD Overlay -->
    <div class="world-hud">
        <!-- Zone shortcuts -->
        <div class="world-zones" id="world-zones"></div>

        <!-- Activity feed -->
        <div class="world-feed" id="world-feed"></div>

        <!-- Agent info panel -->
        <div class="world-info" id="world-info">
            <button class="wi-close" onclick="worldDeselectAgent()">&times;</button>
            <div class="wi-header">
                <div class="wi-avatar" id="wi-avatar">G</div>
                <div>
                    <div class="wi-name" id="wi-name">â€”</div>
                    <div class="wi-role" id="wi-role">â€”</div>
                </div>
                <div class="wi-status" id="wi-status">
                    <span class="dot"></span> <span>idle</span>
                </div>
            </div>
            <div class="wi-task" id="wi-task" style="display:none"></div>
            <div class="wi-skills" id="wi-skills"></div>
        </div>

        <!-- Legend -->
        <div class="world-legend">
            <div class="wl-item"><div class="wl-diamond" style="background:#22c55e"></div> Idle</div>
            <div class="wl-item"><div class="wl-diamond" style="background:#eab308"></div> Thinking</div>
            <div class="wl-item"><div class="wl-diamond" style="background:#3b82f6"></div> Acting</div>
            <div class="wl-item"><div class="wl-diamond" style="background:#a855f7"></div> Waiting</div>
            <div class="wl-item"><div class="wl-diamond" style="background:#ef4444"></div> Error</div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MACARON WORLD â€” 3D Sims-like Agent Visualization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const AGENT_DATA = {{ agents_json|safe }};
const LIVE_DATA = {{ live_json|safe }};

// â”€â”€ Day/Night Mode â”€â”€
let isDayMode = localStorage.getItem('world-day') === '1';
const THEMES = {
    night: { bg: 0x151020, fog: 0x151020, ambient: 0x6040a0, ambientI: 1.0, dirColor: 0xffeedd, dirI: 1.2,
             fillColor: 0xaabbff, fillI: 0.5, hemiSky: 0x9080d0, hemiGnd: 0x302540, hemiI: 0.6,
             floor: 0x1e1830, grid1: 0x302550, grid2: 0x251a40, exposure: 1.4 },
    day:   { bg: 0xb8d0e8, fog: 0xc8ddf0, ambient: 0xffffff, ambientI: 0.6, dirColor: 0xfffaf0, dirI: 1.8,
             fillColor: 0x8ebbff, fillI: 0.7, hemiSky: 0x87ceeb, hemiGnd: 0x8fbc8f, hemiI: 0.8,
             floor: 0xd5cfc2, grid1: 0xc0b8a8, grid2: 0xccc4b4, exposure: 1.0 },
};

// â”€â”€ Zone Definitions â”€â”€
const ZONES = [
    { id:'board',   name:'Board Room',    x:-18, z:-14, w:14, h:8,  color:0xd4a017, floorColor:0x2a2010, floorDay:0xe8dcc0, roles:['dsi','cto','cpo','strat-cpo','strat-cto','lean_portfolio_manager','strat-portfolio'] },
    { id:'meeting', name:'Meeting Room',  x:-18, z:-3,  w:14, h:10, color:0x7c3aed, floorColor:0x201535, floorDay:0xd8d0e8, roles:['scrum_master','chef_projet','agile_coach','chef_de_programme','product_manager','epic_owner','solution_manager'] },
    { id:'dev',     name:'Dev Zone',      x:-18, z:10,  w:14, h:14, color:0x3b82f6, floorColor:0x152040, floorDay:0xc8d8f0, roles:['lead_dev','dev_backend','dev_frontend','dev_mobile','dev_fullstack','worker','ml_engineer','data_engineer','plat-lead-dev','plat-dev-backend','plat-dev-frontend','plat-dev-agents','plat-dev-patterns','plat-dev-infra'] },
    { id:'arch',    name:'Architecture',  x:0,   z:-14, w:14, h:8,  color:0x6366f1, floorColor:0x1a1535, floorDay:0xd0cce8, roles:['enterprise_architect','solution_architect','cloud_architect','architecte','brain'] },
    { id:'qa',      name:'QA Lab',        x:0,   z:-3,  w:14, h:10, color:0x22c55e, floorColor:0x102518, floorDay:0xc0e0c8, roles:['qa_lead','test_automation','test_manager','accessibility_expert','tester','performance_engineer','plat-tma-qa'] },
    { id:'devops',  name:'Server Room',   x:0,   z:10,  w:14, h:14, color:0x06b6d4, floorColor:0x102528, floorDay:0xc0dce0, roles:['devops','sre','dba','pipeline_engineer','devsecops','plat-dev-infra'] },
    { id:'product', name:'Product Corner',x:18,  z:-14, w:14, h:8,  color:0xf97316, floorColor:0x2a1a10, floorDay:0xf0dcc0, roles:['product','product_manager','epic_owner','tech_writer','pmo'] },
    { id:'chill',   name:'Chill Zone',    x:18,  z:0,   w:14, h:12, color:0x84cc16, floorColor:0x182510, floorDay:0xd0e8c0, roles:[] },
];

const STATUS_COLORS = {
    idle:     0x22c55e,
    thinking: 0xeab308,
    acting:   0x3b82f6,
    waiting:  0xa855f7,
    blocked:  0xf97316,
    error:    0xef4444,
    stopped:  0x6b7280,
    paused:   0x6b7280,
};

// â”€â”€ Globals â”€â”€
let scene, camera, renderer, controls, clock;
let agents = {};  // id â†’ { mesh, data, target, status, walkPhase, ... }
let raycaster, mouse;
let selectedAgent = null;
let particleSystems = [];
// Day/Night scene references
let sceneRefs = { ambient: null, dir: null, fill: null, hemi: null, floor: null, grid: null, zoneMeshes: [], trees: [], skyDome: null, fountain: null, stars: null };

// â”€â”€ Loading â”€â”€
const loadBar = document.getElementById('world-load-bar');
const loadScreen = document.getElementById('world-loading');
function setLoadProgress(pct) { loadBar.style.width = pct + '%'; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function init() {
    setLoadProgress(10);
    const canvas = document.getElementById('world-canvas');

    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x151020);
    scene.fog = new THREE.FogExp2(0x151020, 0.006);

    // Camera â€” isometric-ish
    camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 200);
    camera.position.set(35, 30, 35);
    camera.lookAt(0, 0, 0);

    // Renderer
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;

    // Controls
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.maxPolarAngle = Math.PI / 2.2;
    controls.minDistance = 8;
    controls.maxDistance = 80;
    controls.target.set(0, 0, 0);

    // Clock
    clock = new THREE.Clock();

    // Raycaster
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    setLoadProgress(20);
    buildLighting();
    setLoadProgress(30);
    buildFloor();
    setLoadProgress(35);
    buildZones();
    setLoadProgress(40);
    buildWalls();
    setLoadProgress(50);
    buildFurniture();
    setLoadProgress(60);
    buildNature();
    setLoadProgress(70);
    buildAgents();
    setLoadProgress(80);
    buildAmbientParticles();
    setLoadProgress(85);
    buildMissionBoards();
    setLoadProgress(90);
    buildZoneLabelsUI();
    setupInteraction();
    connectSSE();
    seedLiveData();
    if (isDayMode) applyDayNight(true, false);
    document.getElementById('btn-daynight').textContent = isDayMode ? 'â˜€ï¸' : 'ğŸŒ™';

    setLoadProgress(100);
    setTimeout(() => loadScreen.classList.add('hidden'), 400);

    // Resize
    window.addEventListener('resize', onResize);
    window.worldResetCamera = resetCamera;
    window.worldDeselectAgent = deselectAgent;
    window.worldToggleDayNight = toggleDayNight;

    animate();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIGHTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildLighting() {
    const t = isDayMode ? THEMES.day : THEMES.night;
    const ambient = new THREE.AmbientLight(t.ambient, t.ambientI);
    scene.add(ambient);
    sceneRefs.ambient = ambient;

    const dir = new THREE.DirectionalLight(t.dirColor, t.dirI);
    dir.position.set(20, 30, 15);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    dir.shadow.camera.left = -40; dir.shadow.camera.right = 40;
    dir.shadow.camera.top = 40; dir.shadow.camera.bottom = -40;
    dir.shadow.camera.near = 1; dir.shadow.camera.far = 80;
    dir.shadow.bias = -0.001;
    scene.add(dir);
    sceneRefs.dir = dir;

    const fill = new THREE.DirectionalLight(t.fillColor, t.fillI);
    fill.position.set(-15, 20, -10);
    scene.add(fill);
    sceneRefs.fill = fill;

    const hemi = new THREE.HemisphereLight(t.hemiSky, t.hemiGnd, t.hemiI);
    scene.add(hemi);
    sceneRefs.hemi = hemi;

    // Zone point lights
    for (const z of ZONES) {
        const pl = new THREE.PointLight(z.color, isDayMode ? 0.3 : 0.8, 25, 1.5);
        pl.position.set(z.x, 5, z.z);
        scene.add(pl);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLOOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildFloor() {
    const t = isDayMode ? THEMES.day : THEMES.night;
    const floorGeo = new THREE.PlaneGeometry(80, 60);
    const floorMat = new THREE.MeshStandardMaterial({ color: t.floor, roughness: 0.7, metalness: 0.15 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.01;
    floor.receiveShadow = true;
    scene.add(floor);
    sceneRefs.floor = floor;

    const gridHelper = new THREE.GridHelper(80, 40, t.grid1, t.grid2);
    gridHelper.position.y = 0.01;
    scene.add(gridHelper);
    sceneRefs.grid = gridHelper;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZONES â€” colored floor areas
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildZones() {
    for (const z of ZONES) {
        const geo = new THREE.PlaneGeometry(z.w, z.h);
        const mat = new THREE.MeshStandardMaterial({
            color: isDayMode ? z.floorDay : z.floorColor,
            roughness: 0.9, metalness: 0.1, transparent: true, opacity: 0.8,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.set(z.x, 0.02, z.z);
        mesh.receiveShadow = true;
        scene.add(mesh);
        sceneRefs.zoneMeshes.push({ mesh, zone: z });

        const border = new THREE.EdgesGeometry(new THREE.PlaneGeometry(z.w, z.h));
        const borderMat = new THREE.LineBasicMaterial({ color: z.color, transparent: true, opacity: 0.5 });
        const borderLine = new THREE.LineSegments(border, borderMat);
        borderLine.rotation.x = -Math.PI / 2;
        borderLine.position.set(z.x, 0.03, z.z);
        scene.add(borderLine);

        const label = makeTextSprite(z.name, z.color, 0.4);
        label.position.set(z.x - z.w / 2 + 1, 0.1, z.z - z.h / 2 + 0.5);
        scene.add(label);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FURNITURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildFurniture() {
    const woodMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.7 });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x2a2a35, roughness: 0.6 });
    const screenOffMat = new THREE.MeshStandardMaterial({ color: 0x111118, roughness: 0.3, metalness: 0.5 });
    const whiteMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.9 });
    const sofaMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 });
    const chromeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2, metalness: 0.8 });
    const plantGreen = new THREE.MeshStandardMaterial({ color: 0x2d8a4e, roughness: 0.9 });
    const rackMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2a, roughness: 0.5, metalness: 0.3 });

    // â”€â”€ Dev Zone: 12 desks (3 rows Ã— 4) â”€â”€
    for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 4; col++) {
            const dx = -24 + col * 3.2;
            const dz = 5 + row * 4;
            createDesk(dx, dz, woodMat, darkMat, screenOffMat);
        }
    }

    // â”€â”€ QA Lab: 6 desks (2 rows Ã— 3) â”€â”€
    for (let row = 0; row < 2; row++) {
        for (let col = 0; col < 3; col++) {
            const dx = -2 + col * 3.2;
            const dz = -6.5 + row * 4;
            createDesk(dx, dz, woodMat, darkMat, screenOffMat);
        }
    }

    // â”€â”€ Architecture: 3 desks + whiteboard â”€â”€
    for (let col = 0; col < 3; col++) {
        createDesk(-2 + col * 3.2, -16, woodMat, darkMat, screenOffMat);
    }
    // Whiteboard
    const wb = new THREE.Mesh(new THREE.BoxGeometry(4, 2.5, 0.08), whiteMat);
    wb.position.set(0, 2, -17.5);
    wb.castShadow = true;
    scene.add(wb);

    // â”€â”€ Board Room: long table â”€â”€
    const boardTable = new THREE.Mesh(new THREE.BoxGeometry(10, 0.1, 3), woodMat);
    boardTable.position.set(-18, 0.75, -14);
    boardTable.castShadow = true;
    scene.add(boardTable);
    // Board room chairs (6)
    for (let i = 0; i < 3; i++) {
        createChair(-22 + i * 3.5, -12.5, darkMat, 0);
        createChair(-22 + i * 3.5, -15.5, darkMat, Math.PI);
    }
    // Big screen
    const bigScreen = new THREE.Mesh(new THREE.BoxGeometry(6, 3, 0.1), screenOffMat);
    bigScreen.position.set(-18, 2.5, -17.8);
    bigScreen.castShadow = true;
    scene.add(bigScreen);

    // â”€â”€ Meeting Room: round table + chairs â”€â”€
    const roundTable = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 0.08, 24), woodMat);
    roundTable.position.set(-18, 0.75, -3);
    roundTable.castShadow = true;
    scene.add(roundTable);
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        createChair(-18 + Math.cos(angle) * 3, -3 + Math.sin(angle) * 3, darkMat, -angle + Math.PI);
    }

    // â”€â”€ Product Corner: kanban board â”€â”€
    const kanban = new THREE.Mesh(new THREE.BoxGeometry(3.5, 2, 0.08), whiteMat);
    kanban.position.set(18, 2, -17.5);
    kanban.castShadow = true;
    scene.add(kanban);
    // Sticky notes on kanban
    const stickyColors = [0xfde68a, 0xfca5a5, 0x86efac, 0x93c5fd, 0xc4b5fd];
    for (let i = 0; i < 12; i++) {
        const sticky = new THREE.Mesh(
            new THREE.PlaneGeometry(0.5, 0.5),
            new THREE.MeshStandardMaterial({ color: stickyColors[i % stickyColors.length], roughness: 0.9 })
        );
        sticky.position.set(16.5 + (i % 4) * 0.8, 2.8 - Math.floor(i / 4) * 0.65, -17.44);
        scene.add(sticky);
    }
    // Product desks
    for (let col = 0; col < 3; col++) {
        createDesk(16 + col * 3, -13, woodMat, darkMat, screenOffMat);
    }

    // â”€â”€ Server Room: racks â”€â”€
    for (let i = 0; i < 4; i++) {
        const rack = new THREE.Mesh(new THREE.BoxGeometry(0.8, 3, 1.2), rackMat);
        rack.position.set(2 + i * 2.5, 1.5, 15);
        rack.castShadow = true;
        scene.add(rack);
        // LED dots
        for (let j = 0; j < 6; j++) {
            const led = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 6, 6),
                new THREE.MeshBasicMaterial({ color: j % 3 === 0 ? 0x22c55e : 0x3b82f6 })
            );
            led.position.set(2 + i * 2.5 + 0.42, 0.5 + j * 0.4, 14.38);
            led.userData.isLED = true;
            led.userData.blinkSpeed = 0.5 + Math.random() * 2;
            led.userData.blinkOffset = Math.random() * Math.PI * 2;
            scene.add(led);
        }
    }
    // DevOps desks
    for (let col = 0; col < 3; col++) {
        createDesk(-2 + col * 3.2, 11, woodMat, darkMat, screenOffMat);
    }

    // â”€â”€ Chill Zone â”€â”€
    // Sofa
    const sofaBase = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 1.2), sofaMat);
    sofaBase.position.set(18, 0.4, -1);
    sofaBase.castShadow = true;
    scene.add(sofaBase);
    const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(4, 0.6, 0.2), sofaMat);
    sofaBack.position.set(18, 0.8, -1.5);
    scene.add(sofaBack);

    // Coffee machine
    const coffeeCyl = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.6, 12), chromeMat);
    coffeeCyl.position.set(22, 0.75 + 0.3, 2);
    coffeeCyl.castShadow = true;
    scene.add(coffeeCyl);
    // Coffee table
    const coffeeTable = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.05, 0.8), woodMat);
    coffeeTable.position.set(22, 0.75, 2);
    coffeeTable.castShadow = true;
    scene.add(coffeeTable);

    // Plants
    const plantPositions = [[-10, 0], [10, -10], [24, 5], [-24, -18], [8, 18], [-10, 18]];
    for (const [px, pz] of plantPositions) {
        // Pot
        const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.2, 0.4, 8), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
        pot.position.set(px, 0.2, pz);
        scene.add(pot);
        // Canopy
        const canopy = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 6), plantGreen);
        canopy.position.set(px, 0.9, pz);
        canopy.castShadow = true;
        scene.add(canopy);
    }

    // â”€â”€ War Room (inside DevOps zone but separate area) â”€â”€
    const warScreen = new THREE.Mesh(new THREE.BoxGeometry(5, 2.5, 0.1),
        new THREE.MeshStandardMaterial({ color: 0x1a0a0a, emissive: 0x330000, emissiveIntensity: 0.3 }));
    warScreen.position.set(6, 2, 18);
    scene.add(warScreen);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WALLS & BUILDINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildWalls() {
    const wallMat = new THREE.MeshStandardMaterial({
        color: isDayMode ? 0xe8e0d0 : 0x2a2540, transparent: true, opacity: 0.35,
        roughness: 0.8, side: THREE.DoubleSide,
    });
    const wallH = 3.5;

    for (const z of ZONES) {
        if (z.id === 'chill') continue; // open air
        const hw = z.w / 2, hh = z.h / 2;
        // Back wall
        const back = new THREE.Mesh(new THREE.PlaneGeometry(z.w, wallH), wallMat);
        back.position.set(z.x, wallH / 2, z.z - hh);
        scene.add(back);
        // Left wall
        const left = new THREE.Mesh(new THREE.PlaneGeometry(z.h, wallH), wallMat);
        left.rotation.y = Math.PI / 2;
        left.position.set(z.x - hw, wallH / 2, z.z);
        scene.add(left);
        // Sign above entrance
        const sign = makeTextSprite(z.name, z.color, 0.35);
        sign.position.set(z.x, wallH + 0.3, z.z - hh);
        scene.add(sign);
    }

    // Board Room â€” elevated platform
    const platform = new THREE.Mesh(new THREE.BoxGeometry(14, 0.15, 8),
        new THREE.MeshStandardMaterial({ color: isDayMode ? 0xc8b090 : 0x3a2a20, roughness: 0.6 }));
    platform.position.set(-18, 0.075, -14);
    platform.receiveShadow = true;
    scene.add(platform);

    // Corridors â€” floor paths between zones
    const pathMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0xd0c8b8 : 0x252040, roughness: 0.8 });
    const paths = [
        { x: -18, z: 3.5, w: 2, h: 3 },   // devâ†”meeting
        { x: -9, z: -14, w: 4, h: 2 },     // boardâ†”arch
        { x: -9, z: -3, w: 4, h: 2 },      // meetingâ†”qa
        { x: 0, z: 3.5, w: 2, h: 3 },      // qaâ†”devops
        { x: 11, z: -14, w: 4, h: 2 },     // archâ†”product
    ];
    for (const p of paths) {
        const path = new THREE.Mesh(new THREE.PlaneGeometry(p.w, p.h), pathMat);
        path.rotation.x = -Math.PI / 2;
        path.position.set(p.x, 0.015, p.z);
        scene.add(path);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NATURE â€” trees, fountain, skybox
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildNature() {
    // Trees around the perimeter
    const treePositions = [
        [-30, -18], [-30, -8], [-30, 2], [-30, 12], [-30, 20],
        [30, -18], [30, -8], [30, 2], [30, 12], [30, 20],
        [-20, 22], [-10, 22], [0, 22], [10, 22], [20, 22],
        [-20, -20], [-10, -20], [0, -20], [10, -20], [20, -20],
        [24, -6], [26, 8],
    ];
    for (const [tx, tz] of treePositions) {
        const h = 2.5 + Math.random() * 2;
        const trunkMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0x8B5A2B : 0x4a3020, roughness: 0.9 });
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, h * 0.5, 6), trunkMat);
        trunk.position.set(tx, h * 0.25, tz);
        trunk.castShadow = true;
        scene.add(trunk);
        const leafMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0x4CAF50 : 0x1a5c30, roughness: 0.8 });
        const crown = new THREE.Mesh(new THREE.ConeGeometry(h * 0.4, h * 0.6, 6), leafMat);
        crown.position.set(tx, h * 0.7, tz);
        crown.castShadow = true;
        scene.add(crown);
        sceneRefs.trees.push({ trunk, crown });
    }

    // Fountain in chill zone
    const basinMat = new THREE.MeshStandardMaterial({ color: isDayMode ? 0xbbb8b0 : 0x3a3550, roughness: 0.4, metalness: 0.3 });
    const basin = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.8, 0.4, 16), basinMat);
    basin.position.set(18, 0.2, 4);
    scene.add(basin);
    const waterMat = new THREE.MeshStandardMaterial({
        color: isDayMode ? 0x4488cc : 0x2244aa, transparent: true, opacity: 0.6,
        roughness: 0.1, metalness: 0.5,
    });
    const water = new THREE.Mesh(new THREE.CylinderGeometry(1.3, 1.3, 0.05, 16), waterMat);
    water.position.set(18, 0.38, 4);
    scene.add(water);
    sceneRefs.fountain = water;
    // Fountain pillar
    const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 1.2, 8), basinMat);
    pillar.position.set(18, 0.8, 4);
    scene.add(pillar);

    // Sky dome
    const skyGeo = new THREE.SphereGeometry(90, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
    const skyMat = new THREE.MeshBasicMaterial({
        color: isDayMode ? 0x87CEEB : 0x0a0820, side: THREE.BackSide,
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);
    sceneRefs.skyDome = sky;

    // Stars (night only)
    if (!isDayMode) buildStars();
}

function buildStars() {
    const count = 200;
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI * 0.4;
        const r = 85;
        pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
        pos[i*3+1] = r * Math.cos(phi);
        pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3, transparent: true, opacity: 0.7 });
    const stars = new THREE.Points(geo, mat);
    scene.add(stars);
    sceneRefs.stars = stars;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MISSION BOARDS â€” show active missions on screens
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildMissionBoards() {
    const missions = LIVE_DATA.missions || [];
    if (missions.length === 0) return;

    // Board Room big screen â€” show first mission progress
    const m0 = missions[0];
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#1a1030';
    ctx.fillRect(0, 0, 512, 256);
    ctx.fillStyle = '#7c3aed';
    ctx.font = 'bold 22px system-ui';
    ctx.fillText('ğŸ“Š Missions Actives', 20, 35);
    for (let i = 0; i < Math.min(missions.length, 5); i++) {
        const mi = missions[i];
        const y = 70 + i * 36;
        ctx.fillStyle = mi.status === 'running' ? '#3b82f6' : '#6b7280';
        ctx.fillRect(20, y, 472 * (mi.phases_done / Math.max(mi.phases_total, 1)), 20);
        ctx.strokeStyle = '#444';
        ctx.strokeRect(20, y, 472, 20);
        ctx.fillStyle = '#fff';
        ctx.font = '14px system-ui';
        ctx.fillText(`${mi.name} (${mi.phases_done}/${mi.phases_total})`, 25, y + 15);
    }
    const tex = new THREE.CanvasTexture(canvas);
    // Apply to board room big screen
    scene.traverse(obj => {
        if (obj.isMesh && obj.geometry?.parameters?.width === 6 && obj.geometry?.parameters?.height === 3 &&
            Math.abs(obj.position.x - (-18)) < 1 && Math.abs(obj.position.z - (-17.8)) < 1) {
            obj.material = new THREE.MeshStandardMaterial({ map: tex, emissive: 0x111111, emissiveIntensity: 0.3 });
        }
    });

    // Update mission counter
    document.getElementById('world-mission-count').textContent = missions.length + ' missions';
}

function createDesk(x, z, woodMat, darkMat, screenMat) {
    const group = new THREE.Group();
    // Desktop
    const top = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.06, 1), woodMat);
    top.position.y = 0.75;
    top.castShadow = true;
    top.receiveShadow = true;
    group.add(top);
    // Legs
    for (const [lx, lz] of [[-0.9, -0.4], [0.9, -0.4], [-0.9, 0.4], [0.9, 0.4]]) {
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.75, 0.05), darkMat);
        leg.position.set(lx, 0.375, lz);
        group.add(leg);
    }
    // Screen
    const screen = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.55, 0.03), screenMat);
    screen.position.set(0, 1.25, -0.3);
    screen.castShadow = true;
    screen.userData.isScreen = true;
    group.add(screen);
    // Screen stand
    const stand = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.22, 0.05), darkMat);
    stand.position.set(0, 0.89, -0.3);
    group.add(stand);

    group.position.set(x, 0, z);
    scene.add(group);
    return group;
}

function createChair(x, z, mat, rotY) {
    const g = new THREE.Group();
    const seat = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.06, 0.5), mat);
    seat.position.y = 0.45;
    g.add(seat);
    const back = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.06), mat);
    back.position.set(0, 0.7, -0.22);
    g.add(back);
    g.position.set(x, 0, z);
    g.rotation.y = rotY;
    scene.add(g);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AGENTS (Box-people)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildAgents() {
    const zoneDesks = {};
    for (const z of ZONES) zoneDesks[z.id] = { seats: [], idx: 0 };

    // Pre-compute desk positions per zone
    computeZoneSeats(zoneDesks);

    for (const ad of AGENT_DATA) {
        const zone = assignZone(ad);
        const seat = getNextSeat(zoneDesks, zone);
        const agentMesh = createAgentMesh(ad);
        agentMesh.position.set(seat.x, 0, seat.z);
        agentMesh.userData.agentId = ad.id;
        scene.add(agentMesh);

        agents[ad.id] = {
            mesh: agentMesh,
            data: ad,
            zone: zone,
            seat: seat,
            target: { x: seat.x, z: seat.z },
            status: 'idle',
            walkPhase: Math.random() * Math.PI * 2,
            speechBubble: null,
            thoughtBubble: null,
            walkSpeed: 1.5 + Math.random() * 0.5,
            idleTimer: Math.random() * 10,
        };
    }
}

function computeZoneSeats(zoneDesks) {
    // Dev zone: 12 seats
    for (let r = 0; r < 3; r++)
        for (let c = 0; c < 4; c++)
            zoneDesks.dev.seats.push({ x: -24 + c * 3.2, z: 5 + r * 4 + 0.8 });
    // QA: 6 seats
    for (let r = 0; r < 2; r++)
        for (let c = 0; c < 3; c++)
            zoneDesks.qa.seats.push({ x: -2 + c * 3.2, z: -6.5 + r * 4 + 0.8 });
    // Arch: 3 seats
    for (let c = 0; c < 3; c++)
        zoneDesks.arch.seats.push({ x: -2 + c * 3.2, z: -16 + 0.8 });
    // Board: 6 seats
    for (let i = 0; i < 3; i++) {
        zoneDesks.board.seats.push({ x: -22 + i * 3.5, z: -12.5 });
        zoneDesks.board.seats.push({ x: -22 + i * 3.5, z: -15.5 });
    }
    // Meeting: 8 seats around table
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        zoneDesks.meeting.seats.push({ x: -18 + Math.cos(angle) * 3.5, z: -3 + Math.sin(angle) * 3.5 });
    }
    // Product: 3 seats
    for (let c = 0; c < 3; c++)
        zoneDesks.product.seats.push({ x: 16 + c * 3, z: -13 + 0.8 });
    // DevOps: 3 + standing
    for (let c = 0; c < 3; c++)
        zoneDesks.devops.seats.push({ x: -2 + c * 3.2, z: 11 + 0.8 });
    // Chill: scattered
    zoneDesks.chill.seats.push({ x: 17, z: -0.5 }, { x: 19, z: -0.5 }, { x: 18, z: 2 }, { x: 20, z: 3 }, { x: 22, z: 0 });
}

function assignZone(agent) {
    for (const z of ZONES) {
        if (z.roles.includes(agent.id) || z.roles.includes(agent.role)) return z.id;
    }
    // Fallback: use hierarchy_rank
    const rank = agent.hierarchy_rank || 50;
    if (rank <= 10) return 'board';
    if (rank <= 25) return 'arch';
    if (rank <= 40) return 'dev';
    return 'chill';
}

function getNextSeat(zoneDesks, zoneId) {
    const z = zoneDesks[zoneId];
    if (!z || z.seats.length === 0) {
        // Fallback: random position in chill
        return { x: 16 + Math.random() * 8, z: -2 + Math.random() * 8 };
    }
    const seat = z.seats[z.idx % z.seats.length];
    z.idx++;
    // Offset slightly to avoid stacking
    return { x: seat.x + (z.idx > z.seats.length ? (Math.random() - 0.5) * 2 : 0), z: seat.z };
}

function createAgentMesh(agent) {
    const group = new THREE.Group();
    const bodyColor = new THREE.Color(agent.color || '#7c3aed');
    const skinColor = new THREE.Color(0xe8beac);

    // Body
    const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.6 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.6, 0.25), bodyMat);
    body.position.y = 0.95;
    body.castShadow = true;
    group.add(body);

    // Head
    const headMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.7 });
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.3), headMat);
    head.position.y = 1.5;
    head.castShadow = true;
    group.add(head);

    // Arms
    const armMat = new THREE.MeshStandardMaterial({ color: bodyColor.clone().multiplyScalar(0.85), roughness: 0.6 });
    const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.45, 0.12), armMat);
    leftArm.position.set(-0.32, 0.95, 0);
    leftArm.userData.isArm = true;
    group.add(leftArm);
    const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.45, 0.12), armMat);
    rightArm.position.set(0.32, 0.95, 0);
    rightArm.userData.isArm = true;
    group.add(rightArm);

    // Legs
    const legMat = new THREE.MeshStandardMaterial({ color: 0x2a2a3a, roughness: 0.7 });
    const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.5, 0.14), legMat);
    leftLeg.position.set(-0.12, 0.38, 0);
    leftLeg.userData.isLeg = true;
    group.add(leftLeg);
    const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.5, 0.14), legMat);
    rightLeg.position.set(0.12, 0.38, 0);
    rightLeg.userData.isLeg = true;
    group.add(rightLeg);

    // Plumbob (diamond)
    const plumbobGeo = new THREE.OctahedronGeometry(0.15, 0);
    const plumbobMat = new THREE.MeshStandardMaterial({
        color: STATUS_COLORS.idle,
        emissive: STATUS_COLORS.idle,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.85,
    });
    const plumbob = new THREE.Mesh(plumbobGeo, plumbobMat);
    plumbob.position.y = 2.1;
    plumbob.userData.isPlumbob = true;
    group.add(plumbob);

    // Name tag (billboard sprite)
    const nameSprite = makeTextSprite(agent.name, 0xffffff, 0.22);
    nameSprite.position.y = 1.85;
    group.add(nameSprite);

    return group;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEXT SPRITES (canvas â†’ texture â†’ sprite)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function makeTextSprite(text, color, scale = 0.3) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 48;
    ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
    const metrics = ctx.measureText(text);
    const w = Math.ceil(metrics.width) + 20;
    const h = fontSize + 16;
    canvas.width = w;
    canvas.height = h;

    ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
    const c = new THREE.Color(color);
    ctx.fillStyle = `rgba(${c.r*255|0},${c.g*255|0},${c.b*255|0},0.9)`;
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 10, h / 2);

    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(scale * w / h * 2, scale * 2, 1);
    return sprite;
}

function makeSpeechBubble(text, maxWidth = 200) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 28;
    const padding = 16;
    canvas.width = maxWidth + padding * 2;
    canvas.height = 80;

    ctx.font = `${fontSize}px system-ui, sans-serif`;
    // Truncate text
    let displayText = text;
    if (ctx.measureText(text).width > maxWidth) {
        while (ctx.measureText(displayText + 'â€¦').width > maxWidth && displayText.length > 0)
            displayText = displayText.slice(0, -1);
        displayText += 'â€¦';
    }

    // Background
    const tw = ctx.measureText(displayText).width + padding * 2;
    canvas.width = tw;
    ctx.font = `${fontSize}px system-ui, sans-serif`;
    ctx.fillStyle = 'rgba(124,58,237,0.92)';
    roundRect(ctx, 0, 0, tw, 52, 10);
    ctx.fill();
    // Triangle
    ctx.beginPath();
    ctx.moveTo(tw / 2 - 6, 52);
    ctx.lineTo(tw / 2, 64);
    ctx.lineTo(tw / 2 + 6, 52);
    ctx.fill();
    // Text
    ctx.fillStyle = '#fff';
    ctx.textBaseline = 'middle';
    ctx.fillText(displayText, padding / 2, 26);

    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(tw / 60, 64 / 60, 1);
    return sprite;
}

function makeThoughtBubble() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(234,179,8,0.85)';
    ctx.beginPath();
    ctx.arc(32, 24, 22, 0, Math.PI * 2);
    ctx.fill();
    // Dots
    ctx.fillStyle = '#1a1025';
    for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(20 + i * 12, 24, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    // Small bubbles
    ctx.fillStyle = 'rgba(234,179,8,0.6)';
    ctx.beginPath(); ctx.arc(28, 50, 5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(24, 58, 3, 0, Math.PI * 2); ctx.fill();

    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(0.8, 0.8, 1);
    return sprite;
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AMBIENT PARTICLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildAmbientParticles() {
    const count = 60;
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 70;
        positions[i * 3 + 1] = 0.5 + Math.random() * 5;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
        const c = new THREE.Color(0x7c3aed).lerp(new THREE.Color(0x3b82f6), Math.random());
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({
        size: 0.08,
        vertexColors: true,
        transparent: true,
        opacity: 0.5,
        depthWrite: false,
    });
    const particles = new THREE.Points(geo, mat);
    particles.userData.isAmbient = true;
    scene.add(particles);
    particleSystems.push(particles);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANIMATION LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.05);
    const elapsed = clock.getElapsedTime();

    controls.update();

    // Animate agents
    for (const id in agents) {
        const ag = agents[id];
        animateAgent(ag, dt, elapsed);
    }

    // Blink server LEDs
    scene.traverse(obj => {
        if (obj.userData.isLED) {
            const v = Math.sin(elapsed * obj.userData.blinkSpeed + obj.userData.blinkOffset);
            obj.material.opacity = 0.3 + v * 0.7;
            obj.visible = v > -0.3;
        }
    });

    // Ambient particles float
    for (const ps of particleSystems) {
        const pos = ps.geometry.attributes.position;
        for (let i = 0; i < pos.count; i++) {
            pos.array[i * 3 + 1] += Math.sin(elapsed * 0.3 + i) * 0.003;
            pos.array[i * 3] += Math.cos(elapsed * 0.2 + i * 0.5) * 0.002;
        }
        pos.needsUpdate = true;
    }

    // Fountain water wobble
    if (sceneRefs.fountain) {
        sceneRefs.fountain.position.y = 0.38 + Math.sin(elapsed * 2) * 0.02;
        sceneRefs.fountain.rotation.y = elapsed * 0.3;
    }

    renderer.render(scene, camera);
}

function animateAgent(ag, dt, elapsed) {
    const mesh = ag.mesh;
    const plumbob = mesh.children.find(c => c.userData.isPlumbob);
    const arms = mesh.children.filter(c => c.userData.isArm);
    const legs = mesh.children.filter(c => c.userData.isLeg);

    // Plumbob â€” always bob and rotate
    if (plumbob) {
        plumbob.rotation.y += dt * (ag.status === 'thinking' ? 3 : 0.5);
        plumbob.position.y = 2.1 + Math.sin(elapsed * 1.5 + ag.walkPhase) * 0.08;
    }

    // Movement toward target
    const dx = ag.target.x - mesh.position.x;
    const dz = ag.target.z - mesh.position.z;
    const dist = Math.sqrt(dx * dx + dz * dz);

    if (dist > 0.15) {
        // Walking
        const speed = ag.walkSpeed * dt;
        const step = Math.min(speed, dist);
        mesh.position.x += (dx / dist) * step;
        mesh.position.z += (dz / dist) * step;

        // Face direction
        mesh.rotation.y = Math.atan2(dx, dz);

        // Walk cycle
        ag.walkPhase += dt * 8;
        const legSwing = Math.sin(ag.walkPhase) * 0.4;
        if (legs[0]) legs[0].rotation.x = legSwing;
        if (legs[1]) legs[1].rotation.x = -legSwing;
        if (arms[0]) arms[0].rotation.x = -legSwing * 0.6;
        if (arms[1]) arms[1].rotation.x = legSwing * 0.6;
    } else {
        // At destination â€” status-based animation
        // Reset legs
        for (const l of legs) l.rotation.x *= 0.9;

        if (ag.status === 'acting') {
            // Typing â€” arms oscillate fast
            const typingPhase = elapsed * 6 + ag.walkPhase;
            if (arms[0]) arms[0].rotation.x = Math.sin(typingPhase) * 0.25;
            if (arms[1]) arms[1].rotation.x = Math.sin(typingPhase + 1) * 0.25;
        } else if (ag.status === 'thinking') {
            // Subtle sway
            if (arms[0]) arms[0].rotation.x = Math.sin(elapsed * 0.8) * 0.1;
        } else {
            // Idle â€” arms rest
            for (const a of arms) a.rotation.x *= 0.95;
        }

        // Idle behavior â€” occasional head turn
        ag.idleTimer -= dt;
        if (ag.idleTimer <= 0 && ag.status === 'idle') {
            ag.idleTimer = 5 + Math.random() * 10;
            // Small random rotation
            mesh.rotation.y += (Math.random() - 0.5) * 0.5;
        }
    }

    // Speech bubble fade
    if (ag.speechBubble) {
        ag.speechBubble._life -= dt;
        if (ag.speechBubble._life <= 0) {
            mesh.remove(ag.speechBubble);
            ag.speechBubble = null;
        } else if (ag.speechBubble._life < 0.5) {
            ag.speechBubble.material.opacity = ag.speechBubble._life * 2;
        }
    }

    // Thought bubble for thinking status
    if (ag.status === 'thinking' && !ag.thoughtBubble) {
        ag.thoughtBubble = makeThoughtBubble();
        ag.thoughtBubble.position.set(0.4, 2.2, 0);
        mesh.add(ag.thoughtBubble);
    } else if (ag.status !== 'thinking' && ag.thoughtBubble) {
        mesh.remove(ag.thoughtBubble);
        ag.thoughtBubble = null;
    }
    if (ag.thoughtBubble) {
        ag.thoughtBubble.position.y = 2.2 + Math.sin(elapsed * 2) * 0.1;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATUS UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateAgentStatus(agentId, newStatus, task) {
    const ag = agents[agentId];
    if (!ag) return;

    const oldStatus = ag.status;
    ag.status = newStatus;

    // Update plumbob color
    const plumbob = ag.mesh.children.find(c => c.userData.isPlumbob);
    if (plumbob) {
        const color = STATUS_COLORS[newStatus] || STATUS_COLORS.idle;
        plumbob.material.color.setHex(color);
        plumbob.material.emissive.setHex(color);
        plumbob.material.emissiveIntensity = newStatus === 'acting' ? 0.8 : 0.6;
    }

    // Glow nearby screens when acting
    if (newStatus === 'acting') {
        glowNearbyScreen(ag.mesh.position, true);
    } else if (oldStatus === 'acting') {
        glowNearbyScreen(ag.mesh.position, false);
    }

    // Feed item
    addFeedItem(ag.data.name, newStatus, task);

    // Update counters
    updateCounters();
}

function glowNearbyScreen(pos, on) {
    scene.traverse(obj => {
        if (obj.userData.isScreen) {
            const d = obj.getWorldPosition(new THREE.Vector3()).distanceTo(pos);
            if (d < 3) {
                if (on) {
                    obj.material = new THREE.MeshStandardMaterial({
                        color: 0x1a1a2a,
                        emissive: 0x3b82f6,
                        emissiveIntensity: 0.5,
                        roughness: 0.3,
                    });
                } else {
                    obj.material = new THREE.MeshStandardMaterial({
                        color: 0x111118, roughness: 0.3, metalness: 0.5
                    });
                }
            }
        }
    });
}

function showSpeechBubble(agentId, text) {
    const ag = agents[agentId];
    if (!ag) return;

    // Remove old bubble
    if (ag.speechBubble) {
        ag.mesh.remove(ag.speechBubble);
    }

    const bubble = makeSpeechBubble(text);
    bubble.position.set(0, 2.5, 0);
    bubble._life = 5; // seconds
    ag.mesh.add(bubble);
    ag.speechBubble = bubble;
}

function triggerDelegation(fromId, toId) {
    const from = agents[fromId];
    const to = agents[toId];
    if (!from || !to) return;

    // Walk from agent to target agent
    from.target = {
        x: to.mesh.position.x + (Math.random() - 0.5) * 1.5,
        z: to.mesh.position.z + (Math.random() - 0.5) * 1.5
    };

    // After a delay, walk back
    setTimeout(() => {
        from.target = { x: from.seat.x, z: from.seat.z };
    }, 4000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI: FEED, ZONES, COUNTERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const feedEl = document.getElementById('world-feed');

function addFeedItem(name, status, detail) {
    const time = new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
    const item = document.createElement('div');
    item.className = 'wf-item';
    item.innerHTML = `<span class="wf-dot wf-dot--${status}"></span>
        <div><span class="wf-time">${time}</span> <span class="wf-name">${name}</span>
        <span>${statusLabel(status)}${detail ? ' â€” ' + truncate(detail, 40) : ''}</span></div>`;
    feedEl.prepend(item);
    // Keep max 30
    while (feedEl.children.length > 30) feedEl.lastChild.remove();
}

function statusLabel(s) {
    const labels = { idle: 'repos', thinking: 'rÃ©flÃ©chit', acting: 'code', waiting: 'attend', blocked: 'bloquÃ©', error: 'erreur', stopped: 'arrÃªtÃ©' };
    return labels[s] || s;
}

function truncate(s, n) { return s && s.length > n ? s.slice(0, n) + 'â€¦' : s || ''; }

function updateCounters() {
    const total = Object.keys(agents).length;
    const active = Object.values(agents).filter(a => ['thinking', 'acting'].includes(a.status)).length;
    document.getElementById('world-agent-count').textContent = total + ' agents';
    document.getElementById('world-active-count').textContent = active + ' actifs';
}

function buildZoneLabelsUI() {
    const container = document.getElementById('world-zones');
    for (const z of ZONES) {
        const el = document.createElement('div');
        el.className = 'wz-label';
        el.style.borderLeftColor = '#' + z.color.toString(16).padStart(6, '0');
        el.textContent = z.name;
        el.onclick = () => flyToZone(z);
        container.appendChild(el);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTERACTION (click, hover, keyboard)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setupInteraction() {
    const canvas = renderer.domElement;

    canvas.addEventListener('click', (e) => {
        mouse.x = (e.offsetX / canvas.clientWidth) * 2 - 1;
        mouse.y = -(e.offsetY / canvas.clientHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // Find clicked agent
        const agentMeshes = Object.values(agents).map(a => a.mesh);
        const intersects = raycaster.intersectObjects(agentMeshes, true);
        if (intersects.length > 0) {
            let obj = intersects[0].object;
            while (obj.parent && !obj.userData.agentId) obj = obj.parent;
            if (obj.userData.agentId) {
                selectAgent(obj.userData.agentId);
                return;
            }
        }
        deselectAgent();
    });

    // Keyboard
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (e.key === 'Escape') deselectAgent();
        if (e.key === ' ') { e.preventDefault(); resetCamera(); }
        const idx = parseInt(e.key) - 1;
        if (idx >= 0 && idx < ZONES.length) flyToZone(ZONES[idx]);
    });
}

function selectAgent(agentId) {
    const ag = agents[agentId];
    if (!ag) return;
    selectedAgent = agentId;

    // Camera zoom to agent
    const targetPos = ag.mesh.position.clone();
    smoothCameraTo(targetPos.x + 4, 5, targetPos.z + 4, targetPos.x, 1, targetPos.z);

    // Show info panel
    const panel = document.getElementById('world-info');
    panel.style.display = 'block';
    document.getElementById('wi-avatar').textContent = ag.data.avatar || ag.data.name[0];
    document.getElementById('wi-avatar').style.background = ag.data.color;
    document.getElementById('wi-name').textContent = ag.data.name;
    document.getElementById('wi-role').textContent = ag.data.role;
    const statusEl = document.getElementById('wi-status');
    statusEl.querySelector('.dot').style.background = '#' + (STATUS_COLORS[ag.status] || 0x6b7280).toString(16).padStart(6, '0');
    statusEl.querySelector('span:last-child').textContent = statusLabel(ag.status);

    const taskEl = document.getElementById('wi-task');
    const missionText = ag.missionName ? `ğŸš€ ${ag.missionName}` : (ag.data.tagline || '');
    taskEl.style.display = missionText ? 'block' : 'none';
    taskEl.textContent = missionText;

    const skillsEl = document.getElementById('wi-skills');
    skillsEl.innerHTML = '';
    for (const s of (ag.data.skills || []).slice(0, 8)) {
        const tag = document.createElement('span');
        tag.className = 'wi-skill';
        tag.textContent = s;
        skillsEl.appendChild(tag);
    }
}

function deselectAgent() {
    selectedAgent = null;
    document.getElementById('world-info').style.display = 'none';
}

function flyToZone(zone) {
    smoothCameraTo(zone.x + 12, 18, zone.z + 12, zone.x, 0, zone.z);
}

function resetCamera() {
    smoothCameraTo(35, 30, 35, 0, 0, 0);
}

let cameraAnim = null;
function smoothCameraTo(cx, cy, cz, tx, ty, tz) {
    const start = {
        cx: camera.position.x, cy: camera.position.y, cz: camera.position.z,
        tx: controls.target.x, ty: controls.target.y, tz: controls.target.z,
    };
    const end = { cx, cy, cz, tx, ty, tz };
    const duration = 800;
    const startTime = performance.now();

    if (cameraAnim) cancelAnimationFrame(cameraAnim);

    function step() {
        const t = Math.min((performance.now() - startTime) / duration, 1);
        const ease = t < 0.5 ? 2 * t * t : 1 - (-2 * t + 2) ** 2 / 2; // easeInOutQuad
        camera.position.set(
            start.cx + (end.cx - start.cx) * ease,
            start.cy + (end.cy - start.cy) * ease,
            start.cz + (end.cz - start.cz) * ease,
        );
        controls.target.set(
            start.tx + (end.tx - start.tx) * ease,
            start.ty + (end.ty - start.ty) * ease,
            start.tz + (end.tz - start.tz) * ease,
        );
        if (t < 1) cameraAnim = requestAnimationFrame(step);
    }
    step();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SSE â€” Real-time agent status
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function connectSSE() {
    const evtSource = new EventSource('/sse/agents/status');

    evtSource.onmessage = (e) => {
        try {
            const data = JSON.parse(e.data);
            if (data.type === 'agent_status') {
                const agentId = data.agent_id;
                const status = (data.status || 'idle').toLowerCase();
                updateAgentStatus(agentId, status, data.current_task);
            }
            if (data.type === 'message' || data.type === 'stream_end') {
                const fromAgent = data.from_agent || data.agent_id;
                const content = data.content || '';
                if (fromAgent && content) {
                    showSpeechBubble(fromAgent, content);
                    const agName = agents[fromAgent]?.data?.name || fromAgent;
                    addFeedItem(agName, 'acting', content.slice(0, 120));
                }
                // Real interaction â€” walk to target
                if (data.to_agent && agents[fromAgent] && agents[data.to_agent]) {
                    triggerDelegation(fromAgent, data.to_agent);
                }
            }
            if (data.type === 'delegation') {
                triggerDelegation(data.from, data.to);
            }
        } catch (err) { /* ignore parse errors */ }
    };

    evtSource.onerror = () => {
        evtSource.close();
        setTimeout(() => connectSSE(), 5000);
    };

    // Also connect to monitoring SSE for live mission counts
    const monSSE = new EventSource('/sse/monitoring');
    monSSE.onmessage = (e) => {
        try {
            const data = JSON.parse(e.data);
            if (data.type === 'metrics' && data.agents_active !== undefined) {
                document.getElementById('world-active-count').textContent = data.agents_active + ' actifs';
            }
        } catch(err) {}
    };
    monSSE.onerror = () => { monSSE.close(); setTimeout(() => {}, 10000); };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIVE DATA â€” seed from server + SSE for real-time
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function seedLiveData() {
    const messages = LIVE_DATA.messages || [];
    const agentSessions = LIVE_DATA.agent_sessions || {};
    const missions = LIVE_DATA.missions || [];

    // Mark agents with their active session/mission
    for (const [agentId, sessionId] of Object.entries(agentSessions)) {
        if (agents[agentId]) {
            agents[agentId].sessionId = sessionId;
            // Find mission for this session
            const mission = missions.find(m => m.session_id === sessionId);
            if (mission) agents[agentId].missionName = mission.brief || mission.name;
        }
    }

    // Show last N real messages in feed
    const recentMsgs = messages.slice(0, 15);
    for (const msg of recentMsgs.reverse()) {
        const agName = agents[msg.from]?.data?.name || msg.from;
        addFeedItem(agName, 'acting', msg.content);
    }

    // Show real speech bubbles for most recent messages
    for (const msg of messages.slice(0, 5)) {
        if (agents[msg.from]) {
            showSpeechBubble(msg.from, msg.content);
        }
        // If there's a target agent, trigger walk
        if (msg.to && agents[msg.from] && agents[msg.to]) {
            triggerDelegation(msg.from, msg.to);
        }
    }

    // Cluster agents by session â€” agents in same session gather near each other
    const sessionGroups = {};
    for (const [aid, sid] of Object.entries(agentSessions)) {
        if (!sessionGroups[sid]) sessionGroups[sid] = [];
        sessionGroups[sid].push(aid);
    }
    // For groups â‰¥ 2, move them to meeting room area
    const meetingZone = ZONES.find(z => z.id === 'meeting');
    let clusterIdx = 0;
    for (const [sid, agentIds] of Object.entries(sessionGroups)) {
        if (agentIds.length < 2) continue;
        const cx = meetingZone.x + (clusterIdx % 2) * 6 - 3;
        const cz = meetingZone.z + Math.floor(clusterIdx / 2) * 4;
        for (let i = 0; i < agentIds.length; i++) {
            const ag = agents[agentIds[i]];
            if (!ag) continue;
            const angle = (i / agentIds.length) * Math.PI * 2;
            ag.target = { x: cx + Math.cos(angle) * 1.5, z: cz + Math.sin(angle) * 1.5 };
        }
        clusterIdx++;
    }

    updateCounters();

    // Periodic re-fetch of messages (poll every 30s for new activity)
    setInterval(async () => {
        try {
            const resp = await fetch('/api/sessions');
            if (!resp.ok) return;
        } catch(e) { /* ignore */ }
    }, 30000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DAY/NIGHT TOGGLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toggleDayNight() {
    isDayMode = !isDayMode;
    localStorage.setItem('world-day', isDayMode ? '1' : '0');
    document.getElementById('btn-daynight').textContent = isDayMode ? 'â˜€ï¸' : 'ğŸŒ™';
    applyDayNight(isDayMode, true);
}

function applyDayNight(day, animate) {
    const t = day ? THEMES.day : THEMES.night;

    // Scene background + fog
    scene.background = new THREE.Color(t.bg);
    scene.fog = new THREE.FogExp2(t.fog, 0.006);

    // Lights
    if (sceneRefs.ambient) { sceneRefs.ambient.color.setHex(t.ambient); sceneRefs.ambient.intensity = t.ambientI; }
    if (sceneRefs.dir) { sceneRefs.dir.color.setHex(t.dirColor); sceneRefs.dir.intensity = t.dirI; }
    if (sceneRefs.fill) { sceneRefs.fill.color.setHex(t.fillColor); sceneRefs.fill.intensity = t.fillI; }
    if (sceneRefs.hemi) { sceneRefs.hemi.color.setHex(t.hemiSky); sceneRefs.hemi.groundColor.setHex(t.hemiGnd); sceneRefs.hemi.intensity = t.hemiI; }

    // Floor
    if (sceneRefs.floor) sceneRefs.floor.material.color.setHex(t.floor);

    // Zone floors
    for (const { mesh, zone } of sceneRefs.zoneMeshes) {
        mesh.material.color.setHex(day ? zone.floorDay : zone.floorColor);
    }

    // Sky dome
    if (sceneRefs.skyDome) sceneRefs.skyDome.material.color.setHex(day ? 0x87CEEB : 0x0a0820);

    // Stars
    if (sceneRefs.stars) sceneRefs.stars.visible = !day;
    if (!day && !sceneRefs.stars) buildStars();

    // Trees â€” greener in day
    for (const tr of sceneRefs.trees) {
        tr.trunk.material.color.setHex(day ? 0x8B5A2B : 0x4a3020);
        tr.crown.material.color.setHex(day ? 0x4CAF50 : 0x1a5c30);
    }

    // Exposure
    renderer.toneMappingExposure = t.exposure;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESIZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onResize() {
    const canvas = renderer.domElement;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOOTSTRAP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
init();

</script>
{% endblock %}
